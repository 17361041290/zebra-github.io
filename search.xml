<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ts知识点-基础类型</title>
    <url>/2021/11/30/Typescript_01/</url>
    <content><![CDATA[<p><strong>TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6+ 的支持</strong></p>
<blockquote>
<p>安装:<code>npm install -g typescript</code><br>检查是否成功：<code>tsc -V</code></p>
</blockquote>
<blockquote>
<ol>
<li>js文件中使用ts代码,需要编译成js代码才能引入 tsc .\text01.ts</li>
<li>ts文件中使用js代码,可以直接引入</li>
<li>ts文件中函数形参使用某个类型进行修饰，编译后的js文件不会显示【ts:name:string js:name】</li>
<li>ts文件中使用let,编译后为var</li>
<li>ts文件自动编译: </li>
</ol>
<p><strong>5.1 生成配置文件tsconfig.json</strong><br>    <code>tsc --init</code><br><strong>5.2 修改tsconfig.json配置</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;outDir&quot;: &quot;./js&quot;, // 把ts文件最终编译后放在js目录中</span><br><span class="line">&quot;strict&quot;: false, //不使用严格模式</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>5.3 启动监视任务</strong><br>    终端 -&gt; 运行任务 -&gt; 监视tsconfig.json<br>6. 类型注解：一种轻量级的为函数或变量添加约束的方式【name:string】<br>7. 接口：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 接口：一种能力，一种约束而已</span><br><span class="line">(()=&gt;&#123;</span><br><span class="line">    // 定义一个接口</span><br><span class="line">    interface Iperson &#123;</span><br><span class="line">        firstname:string // 姓</span><br><span class="line">        lastname: string // 名</span><br><span class="line">    &#125;</span><br><span class="line">    // 输出姓名</span><br><span class="line">    function showName(person: Iperson) &#123;</span><br><span class="line">        return  person.firstname + person.lastname</span><br><span class="line">    &#125;</span><br><span class="line">    // 定义一个对象</span><br><span class="line">    const person = &#123;</span><br><span class="line">        firstname:&#x27;西门&#x27;,</span><br><span class="line">        lastname: &#x27;吹雪&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(showName(person));</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><br>8. 布尔值类型 字符串类型 数字类型 数组类型 元组类型<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let isDone: boolean = false</span><br><span class="line">let a1: number = 10 // 十进制</span><br><span class="line">let name: string = &#x27;tom&#x27;</span><br><span class="line">// null 和 undefined 是所有类型的子类型 可以把 null 和 undefined 赋值给 number 类型的变量【注意去除严格模式 tsconfig.json &quot;strict&quot;: false, //不使用严格模式】</span><br><span class="line">let u: undefined = undefined</span><br><span class="line">let n: null = null</span><br><span class="line">// 数组类型 里面的数据类型必须和定义数组时候的类型一致</span><br><span class="line">let list1: number[] = [1, 2, 3]</span><br><span class="line">// 数组泛型，Array&lt;元素类型&gt;</span><br><span class="line">let list2: Array&lt;number&gt; = [1, 2, 3]</span><br><span class="line">// 元组类型 类型和数据个数被限定</span><br><span class="line">let t1: [string, number] =  [&#x27;hello&#x27;, 10] // OK</span><br></pre></td></tr></table></figure><br>9. 枚举<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">  Red,</span><br><span class="line">  Green,</span><br><span class="line">  Blue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 枚举数值默认从0开始依次递增</span><br><span class="line">// 根据特定的名称得到对应的枚举数值</span><br><span class="line">let myColor: Color = Color.Green // 1</span><br><span class="line">console.log(myColor, Color.Red, Color.Blue)</span><br></pre></td></tr></table></figure><br>10. any类型 适用任何类型【不清楚类型的变量指定一个类型】<br><code>let str:any = [&#39;asdnjas&#39;]</code><br><code>let list: any[] = [1, true, &#39;free&#39;]</code><br>11. void 表示没有任何类型, 一般用来说明函数的返回值不能是undefined和null之外的值<br>声明一个 void 类型的变量没有什么大用，因为你只能为它赋予 undefined 和 null<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fn(): void &#123;</span><br><span class="line">   console.log(&#x27;fn()&#x27;)</span><br><span class="line">   // return undefined</span><br><span class="line">   // return null</span><br><span class="line">   // return 1 // error</span><br><span class="line"> &#125;</span><br><span class="line">console.log( fn());</span><br></pre></td></tr></table></figure><br>12. object类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fn(obj:object): object &#123;</span><br><span class="line">    console.log(obj);</span><br><span class="line">    // 返回类型是object</span><br><span class="line">    return &#123;</span><br><span class="line">        name:&#x27;he&#x27;,</span><br><span class="line">        age:18</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  let obj = &#123;</span><br><span class="line">    height:1.88,</span><br><span class="line">    weight:90</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(fn(obj));</span><br><span class="line">//   console.log(fn(String));</span><br><span class="line">//   console.log(fn(new String(&#x27;123&#x27;)));</span><br></pre></td></tr></table></figure>
<blockquote>
<ol start="13">
<li>联合类型</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fn(obj:object | string): object &#123;</span><br><span class="line">    console.log(obj);</span><br><span class="line">    return &#123;</span><br><span class="line">        name:&#x27;he&#x27;,</span><br><span class="line">        age:18</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">let obj = &#x27;obj&#x27;</span><br><span class="line">console.log(fn(obj));</span><br><span class="line"></span><br><span class="line">// 类型断言:告诉编译器，我知道我自己是什么类型 写法：1.(&lt;string&gt;变量名) 2.  值 as 类型</span><br><span class="line">function fn(obj: number | string): number &#123;</span><br><span class="line">    //    return obj.toString().length</span><br><span class="line">    if ((&lt;string&gt;obj).length) &#123;</span><br><span class="line">        return (obj as string).length</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return obj.toString().length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj = 123456</span><br><span class="line">console.log(fn(obj));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 类型推断</span><br><span class="line">/* 定义变量时赋值了, 推断为对应的类型 */</span><br><span class="line">let b9 = 123 // number</span><br><span class="line">// b9 = &#x27;abc&#x27; // error</span><br><span class="line"></span><br><span class="line">/* 定义变量时没有赋值, 推断为any类型 */</span><br><span class="line">let b10 // any类型</span><br><span class="line">b10 = 123</span><br><span class="line">b10 = &#x27;abc&#x27;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>Ts知识点-接口</title>
    <url>/2021/11/30/Typescript_02/</url>
    <content><![CDATA[<blockquote>
<p>二、接口</p>
<ol>
<li><strong>可选属性? 只读属性readonly</strong></li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义一个接口 限定约束对象中的数据</span><br><span class="line">interface IPerson &#123;</span><br><span class="line">    // readonly id为只读类型(属性)【不能使用const(变量)】</span><br><span class="line">    readonly id:number,</span><br><span class="line">    name:string,</span><br><span class="line">    age:number,</span><br><span class="line">    // sex为可有可无</span><br><span class="line">    sex?:string</span><br><span class="line">&#125;</span><br><span class="line">const Person:IPerson = &#123;</span><br><span class="line">    id:1,</span><br><span class="line">    name:&#x27;he&#x27;,</span><br><span class="line">    age:23,</span><br><span class="line">    // money:1000, 接口没有，对象不能再添加</span><br><span class="line">&#125;</span><br><span class="line">// Person.money = 1000  接口没有，对象不能再添加</span><br><span class="line">console.log(Person);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>2. 函数类型：通过接口的方式作为函数的类型来使用</strong><br>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。<br>它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 接口</span><br><span class="line">interface Func &#123;</span><br><span class="line">  (source: string, subString: string): boolean</span><br><span class="line">&#125;</span><br><span class="line">// 函数</span><br><span class="line">const mySearch: Func = function(source: string, sub: string): boolean &#123;</span><br><span class="line"> // source 的字符串中查找 sub 字符串</span><br><span class="line">  return source.search(sub) &gt; -1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(mySearch(&#x27;abcd&#x27;, &#x27;bc&#x27;))</span><br><span class="line"></span><br><span class="line">interface Func &#123;</span><br><span class="line">    // 定义一个调用签名</span><br><span class="line">    (name: string, form: string): boolean</span><br><span class="line">&#125;</span><br><span class="line">const handlePerson:Func = function (name: string, form: string): boolean &#123;</span><br><span class="line">    console.log(name+ &#x27;  &#x27; +form);</span><br><span class="line">    return false</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">console.log(handlePerson(&#x27;he&#x27;,&#x27;China&#x27;));</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>3. 类类型</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(() =&gt; &#123;</span><br><span class="line">    // 定义一个接口</span><br><span class="line">    interface IFly &#123;</span><br><span class="line">        fly(),</span><br><span class="line">    &#125;</span><br><span class="line">    interface IRun &#123;</span><br><span class="line">        run()</span><br><span class="line">    &#125;</span><br><span class="line">    let name = &#x27;he&#x27;</span><br><span class="line">    // 类 关系:类实现了这个接口</span><br><span class="line">    // 一个类可以被多个接口约束</span><br><span class="line">    class Person implements IFly, IRun &#123;</span><br><span class="line">        fly() &#123;</span><br><span class="line">            console.log(name + &#x27;我会飞了&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        run() &#123;</span><br><span class="line">            console.log(name + &#x27;我会跑了&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 实例化对象</span><br><span class="line">    const lisi = new Person()</span><br><span class="line">    lisi.fly()</span><br><span class="line">    lisi.run()</span><br><span class="line"></span><br><span class="line">    // 接口可以继承其他多个接口</span><br><span class="line">    // 定义一个接口继承其他接口</span><br><span class="line">    interface IMydoing extends IFly, IRun &#123; &#125;</span><br><span class="line">    // 定义一个类</span><br><span class="line">    class Person2 implements IFly, IRun &#123;</span><br><span class="line">        fly() &#123;</span><br><span class="line">            console.log(&#x27;zhangsan我会飞了&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        run() &#123;</span><br><span class="line">            console.log(&#x27;zhangsan我会跑了&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let zhangsan = new Person2()</span><br><span class="line">    zhangsan.fly()</span><br><span class="line">    zhangsan.run()</span><br><span class="line"></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>Ts知识点-类</title>
    <url>/2021/11/30/Typescript_03/</url>
    <content><![CDATA[<blockquote>
<p>三、类<br><strong>1.基本示例</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(() =&gt; &#123;</span><br><span class="line">    // ts中类的定义</span><br><span class="line">    class Person&#123;</span><br><span class="line">        // 定义属性</span><br><span class="line">        name:string</span><br><span class="line">        age:number</span><br><span class="line">        gender:string </span><br><span class="line">        // 定义构造函数：实例化对象的时候，可以直接对属性值进行初始化</span><br><span class="line">        constructor(name:string=&#x27;he&#x27;,age:number=18,gender:string=&#x27;男&#x27; )&#123;</span><br><span class="line">            // 更新对象中的属性数据</span><br><span class="line">            this.name = name</span><br><span class="line">            this.age = age</span><br><span class="line">            this.gender = gender</span><br><span class="line">        &#125;</span><br><span class="line">        // 定义实例方法</span><br><span class="line">        sayHi(str:string)&#123;</span><br><span class="line">            console.log(`我叫$&#123;this.name&#125;,今年$&#123;this.age&#125;了,我是$&#123;this.gender&#125;的`,str);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        // ts中使用类，实例化对象，进行实例化操作</span><br><span class="line">    &#125;</span><br><span class="line">    const person = new Person(&#x27;lisi&#x27;,28,&#x27;nv&#x27;)</span><br><span class="line">    person.sayHi(&#x27;喜欢编程&#x27;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>2.继承：类与类之间的关系</strong><br>继承后，类与类之间的叫法：A类继承了B类，那么A为子类【派生类】，B类为基类【超类，父类】<br>// 类：可以理解为模板，通过模板实例化对象<br>// 面向对象的编程思想<br><strong>总结：使用关键字extends实现继承，子类可以调用父类中的构造函数，使用super调用,子类中可以重复父类中的方法sayHi</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(() =&gt; &#123;</span><br><span class="line">    // 定义一个类，作为基类【超类，父类】</span><br><span class="line">    class Person&#123;</span><br><span class="line">        // 定义属性</span><br><span class="line">        name:string</span><br><span class="line">        age:number</span><br><span class="line">        gender:string </span><br><span class="line">        // 定义构造函数：实例化对象的时候，可以直接对属性值进行初始化</span><br><span class="line">        constructor(name:string=&#x27;he&#x27;,age:number=18,gender:string=&#x27;男&#x27; )&#123;</span><br><span class="line">            // 更新对象中的属性数据</span><br><span class="line">            this.name = name</span><br><span class="line">            this.age = age</span><br><span class="line">            this.gender = gender</span><br><span class="line">        &#125;</span><br><span class="line">        // 定义实例方法</span><br><span class="line">        sayHi(str:string)&#123;</span><br><span class="line">            console.log(`我叫$&#123;this.name&#125;,今年$&#123;this.age&#125;了,我是$&#123;this.gender&#125;的`,str);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        // ts中使用类，实例化对象，进行实例化操作</span><br><span class="line">    &#125;</span><br><span class="line">    // 定义一个类，作为子类【派生类】</span><br><span class="line">    class Student extends Person&#123;</span><br><span class="line">        constructor(name:string=&#x27;he&#x27;,age:number=18,gender:string=&#x27;男&#x27; ) &#123;</span><br><span class="line">            // super:调用父类中的构造函数</span><br><span class="line">            super(name,age,gender)</span><br><span class="line">        &#125;</span><br><span class="line">        // 调用父类的中方法 </span><br><span class="line">        sayHi()&#123;</span><br><span class="line">            super.sayHi(&#x27;lisi&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 实例化Person Student</span><br><span class="line">    const person = new Person(&#x27;lisi&#x27;,28,&#x27;nv&#x27;)</span><br><span class="line">    const student = new Student(&#x27;lisi&#x27;,28,&#x27;男&#x27;)</span><br><span class="line">    student.sayHi()</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>3.多态：父类型引用了指向子类型的对象，不同类型的对象针对相同的方法，产生了不同的行为</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(() =&gt; &#123;</span><br><span class="line">    // 定义一个父类</span><br><span class="line">    class Person&#123;</span><br><span class="line">        // 定义属性</span><br><span class="line">        name:string</span><br><span class="line">        // 定义构造函数：实例化对象的时候，可以直接对属性值进行初始化</span><br><span class="line">        constructor(name:string=&#x27;he&#x27;)&#123;</span><br><span class="line">            // 更新对象中的属性数据</span><br><span class="line">            this.name = name</span><br><span class="line">        &#125;</span><br><span class="line">        // 定义实例方法</span><br><span class="line">        Run(num:number=0)&#123;</span><br><span class="line">            console.log(`我跑了$&#123;num&#125;公里,`+this.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 定义一个子类</span><br><span class="line">    class Student extends Person&#123;</span><br><span class="line">        constructor(name:string=&#x27;he&#x27;) &#123;</span><br><span class="line">            // super:调用父类中的构造函数</span><br><span class="line">            super(name)</span><br><span class="line">        &#125;</span><br><span class="line">        // 实例方法，重写父类中的实例方法【Run】</span><br><span class="line">        Run(num:number=5)&#123;</span><br><span class="line">            console.log(`我跑了$&#123;num&#125;公里,`+this.name);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 定义一个子类</span><br><span class="line">    class Teacher extends Person&#123;</span><br><span class="line">        constructor(name:string=&#x27;he&#x27;) &#123;</span><br><span class="line">            // super:调用父类中的构造函数</span><br><span class="line">            super(name)</span><br><span class="line">        &#125;</span><br><span class="line">        // 实例方法，重写父类中的实例方法【Run】</span><br><span class="line">        Run(num:number=10)&#123;</span><br><span class="line">            console.log(`我跑了$&#123;num&#125;公里,`+this.name);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实例化Person Student Teacher</span><br><span class="line">    const person:Person = new Person(&#x27;人&#x27;)</span><br><span class="line">    person.Run()</span><br><span class="line">    const student:Student = new Student(&#x27;学生&#x27;)</span><br><span class="line">    student.Run()</span><br><span class="line">    const teacher:Teacher = new Teacher(&#x27;老师&#x27;)</span><br><span class="line">    teacher.Run()</span><br><span class="line"></span><br><span class="line">    // 父类和子类的关系：父子关系，父类类型创建子类的对象</span><br><span class="line">    // 父类型引用了指向子类型的对象</span><br><span class="line">    const student1:Person = new Student(&#x27;学生1&#x27;)</span><br><span class="line">    student1.Run()</span><br><span class="line">    const teacher1:Person = new Teacher(&#x27;老师1&#x27;)</span><br><span class="line">    teacher1.Run()</span><br><span class="line"></span><br><span class="line">    // 不同类型的对象针对相同的方法，产生了不同的行为</span><br><span class="line">    function showRun(person:Person) &#123;</span><br><span class="line">        person.Run()</span><br><span class="line">    &#125;</span><br><span class="line">    showRun(student1)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>4.修饰符（类中成员的修饰符）：主要修饰类中成员的【属性，构造函数，方法】可访问性</strong><br><strong>类中的成员都有默认的修饰符：public【公共的】、private【私人的，子类也无法访问】、protected【只能在子类中使用】readonly【将属性设置为只读的,类中的方法，也不能修改】</strong><br><strong>构造函数constructor中的参数name使用readonly(或者其他修饰符)后，类里面就有了该参数属性name</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(() =&gt; &#123;</span><br><span class="line">    // 定义一个类</span><br><span class="line">    class Person&#123;</span><br><span class="line">        // 定义一个属性</span><br><span class="line">        protected name:string</span><br><span class="line">        public  age:number</span><br><span class="line">        // 定义构造函数：对属性值进行初始化</span><br><span class="line">        constructor(name:string=&#x27;he&#x27;,age:number=10)&#123;</span><br><span class="line">            // 更新对象中的属性数据</span><br><span class="line">            this.name = name</span><br><span class="line">            this.age = age</span><br><span class="line">        &#125;</span><br><span class="line">        // 定义一个实例方法</span><br><span class="line">        protected Run(num:number)&#123;</span><br><span class="line">            console.log(`我跑了$&#123;num&#125;公里,`+this.name+&#x27;,&#x27;+this.age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Student extends Person &#123;</span><br><span class="line">        constructor(name:string=&quot;lisi&quot;,age:number=18) &#123;</span><br><span class="line">            super(name,age)</span><br><span class="line">        &#125;</span><br><span class="line">        Play()&#123;</span><br><span class="line">            super.Run(3)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 实例化对象</span><br><span class="line">    const student = new Student()</span><br><span class="line">    student.Play()</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  readonly name: string = &#x27;abc&#x27;</span><br><span class="line">  constructor(name: string) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let john = new Person(&#x27;John&#x27;)</span><br><span class="line">// john.name = &#x27;peter&#x27; // error</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>5.存取器</strong><br><strong>TypeScript 支持通过 getters/setters 来截取对对象成员的访问</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    firstName: string = &#x27;A&#x27;</span><br><span class="line">    lastName: string = &#x27;B&#x27;</span><br><span class="line">    get fullName() &#123;</span><br><span class="line">      return this.firstName + &#x27;-&#x27; + this.lastName</span><br><span class="line">    &#125;</span><br><span class="line">    set fullName(value) &#123;</span><br><span class="line">      const names = value.split(&#x27;-&#x27;)</span><br><span class="line">      this.firstName = names[0]</span><br><span class="line">      this.lastName = names[1]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  const p = new Person()</span><br><span class="line">  console.log(p.fullName)</span><br><span class="line">  </span><br><span class="line">  p.firstName = &#x27;C&#x27;</span><br><span class="line">  p.lastName = &#x27;D&#x27;</span><br><span class="line">  console.log(p.fullName)</span><br><span class="line">  </span><br><span class="line">  p.fullName = &#x27;E-F&#x27;</span><br><span class="line">  console.log(p.firstName, p.lastName)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>6.静态属性:静态属性、静态方法，通过static来修饰属性和方法</strong><br><strong>静态成员是通过类名.属性或方法来调用的,实例对象不能调用静态属性和静态方法</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(() =&gt; &#123;</span><br><span class="line">    class Person &#123;</span><br><span class="line">        // static name:string 类中默认有name这个属性</span><br><span class="line">        name1: string = &#x27;A&#x27;</span><br><span class="line">        static name2: string = &#x27;B&#x27;</span><br><span class="line">        constructor(name1: string, name2: string) &#123;</span><br><span class="line">            this.name1 = name1</span><br><span class="line">            // this是实例对象，name2为静态属性，实例对象不能调用静态属性</span><br><span class="line">            // this.name2= name2</span><br><span class="line">        &#125;</span><br><span class="line">        static Run() &#123;</span><br><span class="line">            console.log(123);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(Person.name2)</span><br><span class="line">    Person.name2 = &#x27;C&#x27;</span><br><span class="line">    console.log(Person.name2)</span><br><span class="line">    Person.Run()</span><br><span class="line">    // 实例对象不能调用静态属性和静态方法</span><br><span class="line">    // console.log(new Person(&#x27;&#x27;,&#x27;&#x27;).name2)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>7.抽象类：抽象类做为其它派生类的基类使用。 它们不能被实例化</strong><br><strong>不能实例化抽象类的对象 const animal = new Animal()，通过继承的方式实现,一般不用抽象属性</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(() =&gt; &#123;</span><br><span class="line">    abstract class Animal &#123;</span><br><span class="line">        // 抽象方法没有具体内容的实现</span><br><span class="line">        abstract name:string</span><br><span class="line">        abstract cry()</span><br><span class="line">        // abstract cry()&#123;</span><br><span class="line">        //     console.log(123);</span><br><span class="line">        // &#125;</span><br><span class="line"></span><br><span class="line">        run() &#123;</span><br><span class="line">            console.log(&#x27;run()&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Dog extends Animal &#123;</span><br><span class="line">        name:string = &#x27;小白&#x27;</span><br><span class="line">        cry() &#123;</span><br><span class="line">            console.log(this.name+&#x27; Dog cry()&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">        run()&#123;</span><br><span class="line">            console.log(this.name+123);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 不能实例化抽象类的对象 const animal = new Animal()，通过继承的方式实现</span><br><span class="line">    const dog = new Dog()</span><br><span class="line">    dog.cry()</span><br><span class="line">    dog.run()</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>Ts知识点-函数</title>
    <url>/2021/11/30/Typescript_04/</url>
    <content><![CDATA[<blockquote>
<p>四、函数<br><strong>1.写法、可选参数和默认参数、剩余参数</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add(x: number, y: number): number &#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br><span class="line">let add1: number = add(10, 20)</span><br><span class="line"></span><br><span class="line">let myAdd: (x: number, y: number) =&gt; number = function (x: number, y: number): number &#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br><span class="line">let myAdd1= function (x: number, y: number): number &#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let getFullname= function (firstname: string, lastname?: string): string &#123;</span><br><span class="line">    if(lastname)&#123;</span><br><span class="line">        return firstname + lastname</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        console.log(123);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">getFullname(&#x27;he&#x27;)</span><br><span class="line"></span><br><span class="line">    // 剩余参数</span><br><span class="line">function info(x: string, ...args: string[]) &#123;</span><br><span class="line">    console.log(x, args)</span><br><span class="line">&#125;</span><br><span class="line">info(&#x27;abc&#x27;, &#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;) //abc [ &#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27; ]</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>2.函数重载:函数名相同, 而形参不同的多个函数</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(() =&gt; &#123;</span><br><span class="line">    // 重载函数声明</span><br><span class="line">    function add(x: string, y: string): string</span><br><span class="line">    function add(x: number, y: number): number</span><br><span class="line"></span><br><span class="line">    // 定义函数实现</span><br><span class="line">    function add(x: string | number, y: string | number): string | number &#123;</span><br><span class="line">        // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 x + y</span><br><span class="line">        if (typeof x === &#x27;string&#x27; &amp;&amp; typeof y === &#x27;string&#x27;) &#123;</span><br><span class="line">            return x + y</span><br><span class="line">        &#125; else if (typeof x === &#x27;number&#x27; &amp;&amp; typeof y === &#x27;number&#x27;) &#123;</span><br><span class="line">            return x + y</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(add(1, 2))</span><br><span class="line">    console.log(add(&#x27;a&#x27;, &#x27;b&#x27;))</span><br><span class="line">    // console.log(add(1, &#x27;a&#x27;)) // error</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>Ts知识点-泛型和其他</title>
    <url>/2021/11/30/Typescript_05/</url>
    <content><![CDATA[<blockquote>
<p>五、泛型：指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定具体类型的一种特性</p>
</blockquote>
<h1 id="使用函数泛型：不能使用运算符操作泛型"><a href="#使用函数泛型：不能使用运算符操作泛型" class="headerlink" title="使用函数泛型：不能使用运算符操作泛型"></a><strong>使用函数泛型：不能使用运算符操作泛型</strong></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createArray2&lt;T&gt;(value: T, count: number) &#123;</span><br><span class="line">    const arr: Array&lt;T&gt; = []</span><br><span class="line">    for (let index = 0; index &lt; count; index++) &#123;</span><br><span class="line">        arr.push(value)</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line">const arr3 = createArray2&lt;number&gt;(11, 3)</span><br><span class="line">console.log(arr3[0].toFixed())</span><br><span class="line">// console.log(arr3[0].split(&#x27;&#x27;)) // error</span><br><span class="line">const arr4 = createArray2&lt;string&gt;(&#x27;aa&#x27;, 3)</span><br><span class="line">console.log(arr4[0].split(&#x27;&#x27;))</span><br><span class="line">// console.log(arr4[0].toFixed()) // error</span><br></pre></td></tr></table></figure>
<h1 id="多个泛型参数的函数"><a href="#多个泛型参数的函数" class="headerlink" title="多个泛型参数的函数"></a><strong>多个泛型参数的函数</strong></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(() =&gt; &#123;</span><br><span class="line">    function handleSwap&lt;K, V&gt;(a: K, b: V): [K, V] &#123;</span><br><span class="line">        return [a, b]</span><br><span class="line">    &#125;</span><br><span class="line">    const result = handleSwap&lt;string, number&gt;(&#x27;abc&#x27;, 123)</span><br><span class="line">    console.log(result[0].length, result[1].toFixed())</span><br><span class="line"></span><br><span class="line">    function name(a: any, b: any): any &#123;</span><br><span class="line">        return [a, b]</span><br><span class="line">    &#125;</span><br><span class="line">    const num = name(123.12, &#x27;SAD&#x27;)</span><br><span class="line">    console.log(num[0].toFixed());</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h1 id="泛型接口：通过接口去约束函数或类"><a href="#泛型接口：通过接口去约束函数或类" class="headerlink" title="泛型接口：通过接口去约束函数或类"></a><strong>泛型接口：通过接口去约束函数或类</strong></h1><p><strong>在定义接口时, 为接口中的属性或方法定义泛型类型 在使用接口时, 再指定具体的泛型类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(() =&gt; &#123;</span><br><span class="line">    //  需求：定义一个类来存储用户信息</span><br><span class="line">    // 通过一个类的实例对象调用相关方法可以添加多个信息对象，调用</span><br><span class="line"></span><br><span class="line">    // 定义一个泛型接口</span><br><span class="line">    interface IbaseCRUD&lt;T&gt; &#123;</span><br><span class="line">        // Array&lt;T&gt;</span><br><span class="line">        data: T[]</span><br><span class="line">        add: (t: T) =&gt; void</span><br><span class="line">        getById: (id: number) =&gt; T</span><br><span class="line">    &#125;</span><br><span class="line">    // 定义一个用户信息的类</span><br><span class="line">    class User &#123;</span><br><span class="line">        id?: number //id主键自增 ?该属性可有可无</span><br><span class="line">        name: string //姓名</span><br><span class="line">        age: number //年龄</span><br><span class="line"></span><br><span class="line">        constructor(name, age) &#123;</span><br><span class="line">            this.name = name</span><br><span class="line">            this.age = age</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 定一个类，针对用户信息对象进行增加查询的操作</span><br><span class="line">    // CRUD =&gt; 创建，读取，增加，删除</span><br><span class="line">    class UserCRUD implements IbaseCRUD&lt;User&gt; &#123;</span><br><span class="line">        // 用来保存多个User类型的用户信息对象</span><br><span class="line">        data: User[] = []</span><br><span class="line">        // 增加用户信息对象 Math.random() 0~1的随机数</span><br><span class="line">        add(user: User): void &#123;</span><br><span class="line">            user = &#123; ...user, id: Date.now() + Math.random() &#125;</span><br><span class="line">            this.data.push(user)</span><br><span class="line">            console.log(&#x27;保存user&#x27;, user.id)</span><br><span class="line">        &#125;</span><br><span class="line">        // 查询直指定用户的id</span><br><span class="line">        getById(id: number): User &#123;</span><br><span class="line">            return this.data.find(item =&gt; item.id === id)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const userCRUD = new UserCRUD()</span><br><span class="line">    userCRUD.add(new User(&#x27;tom&#x27;, 12))</span><br><span class="line">    userCRUD.add(new User(&#x27;tom2&#x27;, 13))</span><br><span class="line">    console.log(userCRUD.data)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(() =&gt; &#123;</span><br><span class="line">    //  需求：定义一个类来存储用户信息</span><br><span class="line">    // 通过一个类的实例对象调用相关方法可以添加多个信息对象，调用</span><br><span class="line"></span><br><span class="line">    // 定义一个泛型接口</span><br><span class="line">    interface baseinfo&lt;T&gt; &#123;</span><br><span class="line">        data:T[]</span><br><span class="line">        add:(t: T) =&gt; T</span><br><span class="line">    &#125;</span><br><span class="line">    // 定义一个用户信息的类</span><br><span class="line">    class Person &#123;</span><br><span class="line">        id?:number</span><br><span class="line">        name:string </span><br><span class="line">        age:number </span><br><span class="line">        constructor(name:string,age:number)&#123;</span><br><span class="line">            this.name = name</span><br><span class="line">            this.age = age</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 定一个类，针对用户信息对象进行增加查询的操作</span><br><span class="line">    class Listperson implements baseinfo&lt;Person&gt;  &#123;</span><br><span class="line">        data: Array&lt;Person&gt; = []</span><br><span class="line">        // 函数返回值的类型不是any或void,必须有返回值，return</span><br><span class="line">        add(person:Person):Person&#123;</span><br><span class="line">            person = &#123;...person,id:Date.now()+ Math.random()&#125;</span><br><span class="line">            this.data.push(person)</span><br><span class="line">            return person</span><br><span class="line">        &#125;</span><br><span class="line">        getperson(id:number):Person&#123;</span><br><span class="line">            return this.data.find(item =&gt; item.id === id)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const listperson = new Listperson()</span><br><span class="line">    listperson.add(new Person(&#x27;lisa&#x27;,123))</span><br><span class="line">    const &#123; id &#125; = listperson.add(new Person(&#x27;zahng&#x27;,12))</span><br><span class="line">    console.log(listperson.data);</span><br><span class="line">    console.log(id,listperson.getperson(id));</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h1 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a><strong>泛型类</strong></h1><p><strong>在定义类时, 为类中的属性或方法定义泛型类型 在创建类的实例时, 再指定特定的泛型类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(() =&gt; &#123;</span><br><span class="line">    class GenericNumber&lt;T&gt; &#123;</span><br><span class="line">        zeroValue: T</span><br><span class="line">        add: (x: T, y: T) =&gt; T</span><br><span class="line">    &#125;</span><br><span class="line">    let myGenericNumber = new GenericNumber&lt;number&gt;()</span><br><span class="line">    myGenericNumber.zeroValue = 0</span><br><span class="line">    myGenericNumber.add = function (x, y) &#123;</span><br><span class="line">        return x + y</span><br><span class="line">    &#125;</span><br><span class="line">    let myGenericString = new GenericNumber&lt;string&gt;()</span><br><span class="line">    myGenericString.zeroValue = &#x27;abc&#x27;</span><br><span class="line">    myGenericString.add = function (x, y) &#123;</span><br><span class="line">        return x + y</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(myGenericString.add(myGenericString.zeroValue, &#x27;test&#x27;))</span><br><span class="line">    console.log(myGenericNumber.add(myGenericNumber.zeroValue, 12))</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h1 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a><strong>泛型约束</strong></h1><p><strong>如果我们直接对一个泛型参数取 length 属性, 会报错, 因为这个泛型根本就不知道它有这个属性</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(() =&gt; &#123;</span><br><span class="line">    // 没有泛型约束</span><br><span class="line">    function fn&lt;T&gt;(x: T): void &#123;</span><br><span class="line">        // console.log(x.length)  // error</span><br><span class="line">    &#125;</span><br><span class="line">    function fn2(x: number[]): void &#123;</span><br><span class="line">        console.log(x.length)</span><br><span class="line">    &#125;</span><br><span class="line">    interface Lengthwise &#123;</span><br><span class="line">        length: number</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 指定泛型约束</span><br><span class="line">    function fn3&lt;T extends Lengthwise&gt;(x: T): void &#123;</span><br><span class="line">        console.log(x.length)</span><br><span class="line">    &#125;</span><br><span class="line">    fn2([12, 125, 5412, 15, 54])</span><br><span class="line">    fn3([12, 125, 5412, 15, 54])</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>六、 其它</p>
</blockquote>
<h1 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a><strong>声明文件</strong></h1><p><strong>当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。</span><br><span class="line">声明语句: 如果需要ts对新的语法进行检查, 需要要加载了对应的类型说明代码</span><br><span class="line">  declare var jQuery: (selector: string) =&gt; any;</span><br><span class="line">声明文件: 把声明语句放到一个单独的文件（jQuery.d.ts）中, ts会自动解析到项目中所有声明文件</span><br><span class="line">下载声明文件: npm install @types/jquery --save-dev</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">jQuery(&#x27;#foo&#x27;)</span><br><span class="line">// ERROR: Cannot find name &#x27;jQuery&#x27;.</span><br></pre></td></tr></table></figure>
<p><strong>需要使用 declare var 来定义它的类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare var jQuery: (selector: string) =&gt; any</span><br><span class="line"></span><br><span class="line">jQuery(&#x27;#foo&#x27;)</span><br></pre></td></tr></table></figure>
<p><strong>declare var 并没有真的定义一个变量，只是定义了全局变量 jQuery 的类型，仅仅会用于编译时的检查，在编译结果中会被删除。它编译结果是：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jQuery(&#x27;#foo&#x27;)</span><br></pre></td></tr></table></figure>
<p><strong>一般声明文件都会单独写成一个 xxx.d.ts 文件</strong><br><strong>创建 01_jQuery.d.ts, 将声明语句定义其中, TS 编译器会扫描并加载项目中所有的 TS 声明文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare var jQuery: (selector: string) =&gt; any</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">很多的第三方库都定义了对应的声明文件库, 库文件名一般为 @types/xxx, 可以在 https://www.npmjs.com/package/package 进行搜索</span><br><span class="line"></span><br><span class="line">有的第三库在下载时就会自动下载对应的声明文件库(比如: webpack),有的可能需要单独下载(比如 jQuery/react)</span><br></pre></td></tr></table></figure>
<h1 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a><strong>内置对象</strong></h1><p><strong>JavaScript 中有很多内置对象，它们可以直接在 TypeScript 中当做定义好了的类型</strong><br><strong>ECMAScript 的内置对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 1. ECMAScript 的内置对象 */</span><br><span class="line">    let b: Boolean = new Boolean(1)</span><br><span class="line">    let n: Number = new Number(true)</span><br><span class="line">    let s: String = new String(&#x27;abc&#x27;)</span><br><span class="line">    let d: Date = new Date()</span><br><span class="line">    let r: RegExp = /^1/</span><br><span class="line">    let e: Error = new Error(&#x27;error message&#x27;)</span><br><span class="line">    // 以上都是对象</span><br><span class="line">    b = true</span><br><span class="line">    // let bb: boolean = new Boolean(2)  // error</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>BOM 和 DOM 的内置对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const div: HTMLElement = document.getElementById(&#x27;test&#x27;)</span><br><span class="line">const divs: NodeList = document.querySelectorAll(&#x27;div&#x27;)</span><br><span class="line">document.addEventListener(&#x27;click&#x27;, (event: MouseEvent) =&gt; &#123;</span><br><span class="line">  console.dir(event.target)</span><br><span class="line">&#125;)</span><br><span class="line">const fragment: DocumentFragment = document.createDocumentFragment()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6或以上的数组方法</title>
    <url>/2021/06/07/javascript_a_1/</url>
    <content><![CDATA[<p>every: 一假即假<br>some: 一真即真<br>every 和 some目的：确定数组的所有成员是否满足指定的测试<br>some、every返回true、false</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr =[</span><br><span class="line">    &#123;&#x27;name&#x27;:&#x27;张三&#x27;,&#x27;num&#x27;:65&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;:&#x27;李四&#x27;,&#x27;num&#x27;:15&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;:&#x27;李五&#x27;,&#x27;num&#x27;:90&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;:&#x27;赵六&#x27;,&#x27;num&#x27;:99&#125;</span><br><span class="line">]</span><br><span class="line">let every = arr.every( (item) =&gt; &#123;</span><br><span class="line">    return item.num &gt;= 60</span><br><span class="line">&#125;)</span><br><span class="line">console.log(every ? &#x27;满足全部大于等于60的&#x27;:&#x27;有小于60的&#x27;)</span><br><span class="line"></span><br><span class="line">let some = arr.some( (item) =&gt; &#123;</span><br><span class="line">    return item.num &gt;= 60</span><br><span class="line">&#125;)</span><br><span class="line">console.log(some ? &#x27;有大于等于60的&#x27;:&#x27;全部小于60的&#x27;)</span><br><span class="line"></span><br><span class="line">//取出过滤后的数据</span><br><span class="line">let reduce =  arr.reduce((preVal, curVal, index, arr) =&gt; &#123;</span><br><span class="line">curVal.num &gt;= 60 ? preVal.push(curVal) : &#x27;&#x27;</span><br><span class="line">return preVal</span><br><span class="line">&#125;, [])</span><br><span class="line">console.log(reduce)</span><br><span class="line"></span><br><span class="line">//对象里的属性求和</span><br><span class="line">let sum = arr.reduce((preVal, curVal)=&gt; &#123;</span><br><span class="line">return curVal.num + preVal;</span><br><span class="line">&#125;, 0);</span><br><span class="line">console.log(sum) //269</span><br></pre></td></tr></table></figure>

<blockquote>
<p>reduce的其他用法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求和</span></span><br><span class="line"><span class="keyword">let</span> arr =[<span class="number">1</span>,<span class="number">12</span>,<span class="number">45</span>,<span class="number">56</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">54</span>,<span class="number">1</span>,<span class="number">23</span>]</span><br><span class="line"><span class="keyword">let</span> res =  arr.reduce(<span class="function">(<span class="params">preVal, curVal</span>) =&gt;</span> preVal + curVal)</span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">//212</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//去重</span></span><br><span class="line"><span class="keyword">let</span> arr =[<span class="number">1</span>,<span class="number">12</span>,<span class="number">45</span>,<span class="number">56</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">54</span>,<span class="number">1</span>,<span class="number">23</span>]</span><br><span class="line"><span class="keyword">let</span> res =  arr.reduce(<span class="function">(<span class="params">preVal, curVal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!preVal.includes(curVal))&#123;</span><br><span class="line">        <span class="keyword">return</span> preVal.concat(curVal)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> preVal</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,[])</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line"><span class="comment">// [1, 12, 45, 56, 8, 54, 23]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//降维</span></span><br><span class="line"><span class="keyword">let</span> arr = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.reduce(<span class="function">(<span class="params">preVal,curVal</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> preVal.concat(curVal)</span><br><span class="line">&#125;,[])</span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>打印出每一个数字</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 打印出每一个数字</span><br><span class="line">let arr = [1, 2, [3, 4, [5, 6], 7, 8], 9, 10];</span><br><span class="line"></span><br><span class="line">// 1.flat方法</span><br><span class="line">for(let i = 0;i&lt;arr.flat(2).length ; i++ )&#123;</span><br><span class="line">    console.log(arr.flat(2).sort(function(a,b)&#123;return a-b&#125;)[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2.递归函数</span><br><span class="line">let Fnc = function (arr) &#123;</span><br><span class="line">    for(let i = 0; i&lt;arr.length;i++)&#123;</span><br><span class="line">        if(typeof arr[i] == &#x27;object&#x27;)&#123;</span><br><span class="line">             Fnc(arr[i])</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">             console.log(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Fnc(arr)</span><br><span class="line"></span><br><span class="line">// 3.链式调用数组方法</span><br><span class="line">// let arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14,15] ] ] ], 10]</span><br><span class="line">let dt = arr.toString().split(&#x27;,&#x27;).sort(function(a,b)&#123;return a-b&#125;).map(Number)</span><br><span class="line">// 去重打印</span><br><span class="line"> Array.from(new Set(dt)).map(i=&gt; console.log(&#x27;链式调用&#x27;,i))</span><br><span class="line"></span><br><span class="line">// 4.JSON.stringify</span><br><span class="line">let str = JSON.stringify(arr).replace(/\[|]/g,&#x27;&#x27;).split(&#x27;,&#x27;).map(Number);</span><br><span class="line">Array.from(new Set(str)).map(i=&gt; console.log(&#x27;JSON.stringify&#x27;,i))</span><br><span class="line"></span><br><span class="line">// 5.toString</span><br><span class="line">let dt1 = arr.toString().split(&#x27;,&#x27;).map(Number)</span><br><span class="line">Array.from(new Set(dt1)).map(i=&gt; console.log(&#x27;toString&#x27;,i))</span><br><span class="line"></span><br><span class="line">// 6.for循环(不是最优解：不建议使用)</span><br><span class="line">let newArr = []</span><br><span class="line">for(let i = 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    if(typeof arr[i] == &#x27;number&#x27;)&#123;</span><br><span class="line">        newArr.push(arr[i])</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        for(let j = 0;j&lt;arr[i].length;j++)&#123;</span><br><span class="line">            if(typeof arr[i][j] == &#x27;number&#x27;)&#123;</span><br><span class="line">                newArr.push(arr[i][j])</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                for(let k = 0;k&lt;arr[i][j].length;k++)&#123;</span><br><span class="line">                    newArr.push(arr[i][j][k])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">newArr.map(i =&gt; console.log(i))</span><br></pre></td></tr></table></figure>
<span id="more"></span>
]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>js知识点</title>
    <url>/2021/06/10/javascript_a_2/</url>
    <content><![CDATA[<p>js缺陷：没有模块系统，标椎库较少，没有标椎接口，缺乏管理系统<br>模块化：将一个完整的程序，分成多个程序。（一段庞大的js代码分成多个js文件代码，降低程序之间的耦合性，方便代码复用）<br>模块化的特点：<br>1.在node中，一个js文件就是一个模块，通过require()函数来引入外部模块（js文件引入js文件）<br>2.在node中，每一个js文件中的js代码都是独立运行在一个函数中，而不是全局作用域（即a.js文件里的定义的变量，a.js文件通过require（）引入进b.js文件后，b.js文件无法直接访问到a.js文件里的变量，可以通过exports来暴露变量和方法）</p>
<p>require()可以传递一个文件的路径作为参数，node将会自动根据该路径来引入外部模块<br>这里的路径，如果使用相对路径，必须以.或..开头</p>
<p>首先找自身，然后才是找上层，如果上层没有，则报错而不是undefined<br>这是沿着作用域链找变量找不到就报错，而沿着原型链找没找到则是null</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var num = 100 </span><br><span class="line">function fn() &#123;</span><br><span class="line">    var num = 200</span><br><span class="line">    function fn2() &#123;</span><br><span class="line">        var num = 300</span><br><span class="line">        console.log(num); //300</span><br><span class="line">    &#125;</span><br><span class="line">    fn2()</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>js知识点-异步编程</title>
    <url>/2021/11/21/javascript_a_3/</url>
    <content><![CDATA[<blockquote>
<p><strong>1. 异步编程</strong><br>同步：同一时间只能做一件事<br>异步：同一时间做多件事<br><strong>1.2 JS中的异步实现：单线程非阻塞式</strong><br><strong>JS单线程：不是只js引擎只有一个线程。运行代码只有一个线程，但是还有其他线程来执行其他代码。</strong><br>例如：时间函数的计时，AJAX技术中的和后台交互等<br><strong>注意：由于执行代码只有一个线程，所以同步代码中出现死循环，后续同步代码以及异步的回调函数都无法执行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&quot;start&quot;);</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">console.log(&quot;timeout&quot;);</span><br><span class="line">&#125;,5000);</span><br><span class="line">console.log(&quot;end&quot;);</span><br><span class="line">// start end 等待5秒 timeout</span><br><span class="line">// setTimeout方法，放入队列中</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>2. ES6:Promise实现异步</strong><br><strong>参数：Promise构造函数接收一个回调函数，回调函数接收两个参数resolve，reject，通过Promise对象的then方法实现异步</strong><br>Promise的作用：避免回调地狱<br><strong>2.1 reject是出现错误时调用的方法，触发catch中的回调函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let pm = new Promise(function(resolve,reject)&#123;</span><br><span class="line">   console.log(&quot;异步开始&quot;);</span><br><span class="line">   resolve()</span><br><span class="line">   //dosomething</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&quot;go on&quot;);</span><br><span class="line">pm.then(function()&#123;</span><br><span class="line">   console.log(&quot;异步完成&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">// 1.异步开始 2.go on 3.异步完成</span><br><span class="line">// then方法将内容放入队列</span><br><span class="line"></span><br><span class="line">// 调用resolve可以把数据传递给then的回调函数</span><br><span class="line">let err = true</span><br><span class="line">let pm = new Promise(function(resolve,reject)&#123;</span><br><span class="line">   if(!err)&#123;</span><br><span class="line">       resolve(&quot;this is data&quot;);</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">       reject(&quot;fail&quot;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">console.log(&quot;go on&quot;);</span><br><span class="line">pm.then(function(data)&#123;</span><br><span class="line">   console.log(&quot;异步完成&quot;,data);</span><br><span class="line">&#125;);</span><br><span class="line">pm.catch(function(err)&#123;</span><br><span class="line">   console.log(&quot;出现错误&quot;,err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>2.2 封装Promise，避免多次创建</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let timeout = function(time)&#123;</span><br><span class="line">   return new Promise(function(resolve,reject)&#123;</span><br><span class="line">       setTimeout(function()&#123;</span><br><span class="line">           resolve();</span><br><span class="line">       &#125;,time);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(&quot;go on&quot;);</span><br><span class="line">timeout(2000).then(function()&#123;</span><br><span class="line">   console.log(&quot;first&quot;);</span><br><span class="line">   return timeout(2000);</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">   console.log(&quot;second&quot;);</span><br><span class="line">   return timeout(2000);</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">   console.log(&quot;third&quot;);</span><br><span class="line">   return timeout(2000);</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">   console.log(&quot;fourth&quot;);</span><br><span class="line">   return timeout(2000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>3.生成器和迭代器</strong><br><strong>3.1 迭代器</strong><br>迭代器：提供统一的遍历数据的方式，只要在遍历的数据结构中添加一个支持迭代器的属性：[Symbol.iterator]<br>默认支持迭代器的结构【for of循环】：Array、Map、Set、String、TypedArray、函数的arguments对象、NodeList对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let ary = [1,2,3];</span><br><span class="line">let it = ary[Symbol.iterator](); // ឴ݐහᕟӾጱᬽդ࢏</span><br><span class="line">console.log(it.next()); // &#123; value: 1, done: false &#125;</span><br><span class="line">console.log(it.next()); // &#123; value: 2, done: false &#125;</span><br><span class="line">console.log(it.next()); // &#123; value: 3, done: false &#125;</span><br><span class="line">console.log(it.next()); // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>
<p><strong>迭代器遍历对象【for in 更好点】</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">   name: &#x27;xiejie&#x27;,</span><br><span class="line">   age: 18,</span><br><span class="line">   gender: &#x27;男&#x27;,</span><br><span class="line">   intro: function () &#123;</span><br><span class="line">       console.log(&#x27;my name is &#x27; + this.name);</span><br><span class="line">   &#125;,</span><br><span class="line">   [Symbol.iterator]: function () &#123;</span><br><span class="line">       let i = 0;</span><br><span class="line">       let keys = Object.keys(this); // 获取当前对象的所有属性形成一个数组</span><br><span class="line">       return &#123;</span><br><span class="line">           next: function () &#123;</span><br><span class="line">               return &#123;</span><br><span class="line">                   value: keys[i++], // 外部每次执行next都能得到数组中的第i个元素</span><br><span class="line">                   done: i &gt; keys.length // 数组数据遍历完返回true</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">for (let attr of obj) &#123;</span><br><span class="line">   console.log(attr+ &#x27;  &#x27;+obj[attr]);</span><br><span class="line">&#125;</span><br><span class="line">// let it = obj[Symbol.iterator]();</span><br><span class="line">// console.log(it.next()); // &#123; value: &#x27;name&#x27;, done: false &#125;</span><br><span class="line">// console.log(it.next()); // &#123; value: &#x27;age&#x27;, done: false &#125;</span><br><span class="line">// console.log(it.next()); // &#123; value: &#x27;gender&#x27;, done: false &#125;</span><br><span class="line">// console.log(it.next()); // &#123; value: &#x27;intro&#x27;, done: false &#125;</span><br><span class="line">// console.log(it.next()); // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.2 生成器</strong><br><strong>写法：在声名函数时加<em>，</em>在function关键词后面</strong><br><code>function* say()&#123;&#125; const say = function*()&#123;&#125;</code><br><strong>生成器函数和普通函数的区别：</strong><br>1.普通函数在调用后，必然开始执行函数，直到执行完成或者return，中途不暂停<br>2.生成器函数可以通过【yield关键字】将函数挂起，或者理解为暂停，外部通过调用next方法，让函数继续执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function* say()&#123;</span><br><span class="line">   yield &quot;开始&quot;;</span><br><span class="line">   yield &quot;执行中&quot;;</span><br><span class="line">   yield &quot;结束&quot;; &#125;</span><br><span class="line">let it = say(); // 调用say函数，得到迭代器</span><br><span class="line">for(let i of it)&#123;</span><br><span class="line">   console.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(it.next()); // &#123; value: &#x27;开始&#x27;, done: false &#125;</span><br><span class="line">console.log(it.next()); // &#123; value: &#x27;执行中&#x27;, done: false &#125;</span><br><span class="line">console.log(it.next()); // &#123; value: &#x27;结束&#x27;, done: false &#125;</span><br><span class="line">console.log(it.next()); // &#123; value: undefined, done: true &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>生成器实现异步操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function* delay() &#123;</span><br><span class="line">   yield new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve() &#125;,</span><br><span class="line">       1)    &#125;)</span><br><span class="line">   console.log(&quot;go on&quot;);</span><br><span class="line">&#125;</span><br><span class="line">let it = delay(); // 得到迭代器</span><br><span class="line">it.next().value.then(() =&gt; &#123;</span><br><span class="line">   it.next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>4. ES7:async和await</strong><br>async函数处理异步，实际上只是生成器的语法糖<br>async执行顺序：先执行同步代码，然后通过执行器来执行async里的代码，有返回值在外部通过then()方法的回调函数来接收<br><strong>await后面必须是一个Promise对象【因为promise对象会返回给外部执行器，并在异步完成后执行resolve】</strong><br><strong>如果await后面不是Promise对象，await会把他包装成一个Promise对象</strong><br><strong>通过关键字async，外部产生了相应的执行器来执行，在异步操作完成后执行回调函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function delay()&#123;</span><br><span class="line">await new Promise((resolve) =&gt; &#123;setTimeout(()=&gt;&#123;resolve()&#125;,2000)&#125;);</span><br><span class="line">console.log(&quot;go on);</span><br><span class="line">&#125;</span><br><span class="line">delay();</span><br></pre></td></tr></table></figure>
<p><code>// 箭头函数写在参数前面 const delay = async () =&gt; &#123;&#125;</code><br><img src="/images/async.png" alt="执行步骤"><br><strong>2.获取async函数的返回结果实际是return出来的promise对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 得到返回的具体内容</span><br><span class="line">const delay = async () =&gt; &#123;</span><br><span class="line">   await  new Promise((resolve) =&gt; &#123;setTimeout(()=&gt;&#123; console.log(&quot;123&quot;); resolve()&#125;,2000)&#125;);</span><br><span class="line">   return &quot;finish&quot;;</span><br><span class="line">&#125;</span><br><span class="line">let result = delay();</span><br><span class="line">console.log(result);</span><br><span class="line">result.then(function(data)&#123;</span><br><span class="line">   console.log(&quot;data:&quot;,data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>多个异步操作进行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function time(ms)&#123;</span><br><span class="line">   return new Promise((resolve,reject) =&gt; &#123;</span><br><span class="line">       setTimeout(()=&gt;&#123;resolve()&#125;,ms);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line">const delay = async () =&gt; &#123;</span><br><span class="line">   await time(2000);</span><br><span class="line">   console.log(&quot;t1 finish&quot;);</span><br><span class="line">   await time(2000);;</span><br><span class="line">   console.log(&quot;t2 finish&quot;);</span><br><span class="line">&#125;</span><br><span class="line">delay()</span><br></pre></td></tr></table></figure></blockquote>
]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>客户端、服务器和数据库的关系</title>
    <url>/2021/08/26/node/</url>
    <content><![CDATA[<p>客户端向服务器发起请求，服务器去数据库调数据，数据库返回数据，服务器响应再把数据返回给客户端<br>i/o问题:会影响拿取数据的速度，磁盘（固态硬盘）的读写速度有限制</p>
<p>i/o input:往磁盘输入数据 output:从磁盘输出数据<br>服务器通过磁盘输入或者输出数据库</p>
<p>进程：程序（相当于是一个一个的车间）<br>线程：（相当于车间里的工人）如果磁盘读写（i/o）速度过慢，该线程就会一直等待，存在内存浪费<br>解决办法：让线程不再等待，继续工作,所以只需要一个线程<br>多线程：<br>单线程：node.js<br>node.js存在的问题：处理不了多用户访问请求（解决：分布式服务器，即增加服务器的数量）<br>node.js优点：访问速度快<br>node.js出现的目的：用node.js编写一个高性能的服务器<br><img src="/images/node.png" alt="image"></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3基础（一）</title>
    <url>/2021/11/10/vue3_a_1/</url>
    <content><![CDATA[<p><strong>Vue3基础（一）:</strong> &lt;Excerpt in index | 首页摘要&gt;</p>
<blockquote>
<p><strong>vue2与vue3的区别:</strong></p>
<ol>
<li>vue3采用Proxy代理 vue2采用Object.defineproperty进行对数据的操作</li>
<li>2.Vue 3 有 createApp&#40;&#41;，而 Vue 2 的是 new Vue&#40;&#41;</li>
</ol>
</blockquote>
<blockquote>
<p><strong>引入方式：</strong></p>
<ol>
<li>vue3:<code>&lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;</code></li>
<li>vue2:<code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;</code></li>
</ol>
</blockquote>
<blockquote>
<p><strong>写法：</strong><br>vue3:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const Conter = &#123;</span><br><span class="line">           data() &#123;</span><br><span class="line">               return &#123;</span><br><span class="line">                   a: 10</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;,</span><br><span class="line">           mounted() &#123;</span><br><span class="line">               // setInterval(() =&gt; &#123;</span><br><span class="line">               //     this.a++</span><br><span class="line">               // &#125;, 1000)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">let app = Vue.createApp(Conter).mount(&#x27;#app&#x27;)</span><br><span class="line">console.log(app);</span><br></pre></td></tr></table></figure>
<p>vue2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let app = new Vue(&#123;</span><br><span class="line">    el:&#x27;#app&#x27;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        a:1111</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>使用 Vite 快速构建 Vue 项目:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># npm 6.x</span><br><span class="line">$ npm init vite@latest &lt;project-name&gt; --template vue</span><br><span class="line"></span><br><span class="line"># npm 7+，需要加上额外的双短横线</span><br><span class="line">$ npm init vite@latest &lt;project-name&gt; -- --template vue</span><br><span class="line"></span><br><span class="line">$ cd &lt;project-name&gt;</span><br><span class="line">$ npm install</span><br><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>Vue3基础</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3其他Composition api</title>
    <url>/2021/12/14/vue3_a_3/</url>
    <content><![CDATA[<h1 id="shallowReactive-与-shallowRef"><a href="#shallowReactive-与-shallowRef" class="headerlink" title="shallowReactive 与 shallowRef"></a><strong>shallowReactive 与 shallowRef</strong></h1><ul>
<li>shallowReactive : 只处理了对象内最外层属性的响应式(也就是浅响应式)</li>
<li>shallowRef: 只处理了 value 的响应式, 不进行对象的 reactive 处理<blockquote>
<p><em>什么时候用浅响应式呢?</em></p>
<ol>
<li>一般情况下使用 ref 和 reactive 即可</li>
<li>如果有一个对象数据, 结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive</li>
<li>如果有一个对象数据, 后面会产生新的对象来替换 ===&gt; shallowRef</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;shallowReactive 与 shallowRef&lt;/h2&gt;</span><br><span class="line">  &lt;h3&gt;m1:&#123;&#123; m1 &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;h3&gt;m2:&#123;&#123; m2 &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;h3&gt;m3:&#123;&#123; m3 &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;h3&gt;m4:&#123;&#123; m4 &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;hr /&gt;</span><br><span class="line">  &lt;button @click=&quot;handleUpdata&quot;&gt;更新数据&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123;</span><br><span class="line">  defineComponent,</span><br><span class="line">  reactive,</span><br><span class="line">  ref,</span><br><span class="line">  shallowReactive,</span><br><span class="line">  shallowRef,</span><br><span class="line">&#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &quot;&quot;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">     // m1 reactive 深度劫持，深度响应式</span><br><span class="line">    const m1 = reactive(&#123; a: 1, b: &#123; c: 2 &#125; &#125;)</span><br><span class="line">    const m2 = shallowReactive(&#123; a: 1, b: &#123; c: 2 &#125; &#125;)</span><br><span class="line"></span><br><span class="line">    const m3 = ref(&#123; a: 1, b: &#123; c: 2 &#125; &#125;)</span><br><span class="line">    const m4 = shallowRef(&#123; x: 1, y: &#123; c: &#x27;2&#x27; &#125; &#125;)</span><br><span class="line"></span><br><span class="line">    const handleUpdata = () =&gt; &#123;</span><br><span class="line">      // m1.b.c += 1</span><br><span class="line">      // m2.b.c += 1</span><br><span class="line">      // m3.value.a += 1</span><br><span class="line">      // m3.value.b.c += 1</span><br><span class="line">      // m4.value.y.c += 1</span><br><span class="line">      console.log(m3);</span><br><span class="line">      console.log(m4);</span><br><span class="line">      </span><br><span class="line">      // 为什么reactive或ref在使用时，shallowRef和shallowReactive的数据会变成响应式？</span><br><span class="line">      // 数据处于同一环境，都被同一个Fragment包着，Fragment是一种VNode的类型，m1.b.c触发改变</span><br><span class="line">      // 对应的模板领域会进行更新，所以会发生改变</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      m1,</span><br><span class="line">      m2,</span><br><span class="line">      m3,</span><br><span class="line">      m4,</span><br><span class="line">      handleUpdata,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="readonly-与-shallowReadonly"><a href="#readonly-与-shallowReadonly" class="headerlink" title="readonly 与 shallowReadonly"></a><strong>readonly 与 shallowReadonly</strong></h1><ul>
<li>readonly 深度只读数据   shallowReadonly: 浅只读数据<blockquote>
<p><strong>应用场景:</strong><br><strong>在某些特定情况下, 我们可能不希望对数据进行更新的操作, 那就可以包装生成一个只读代理对象来读取数据, 而不能修改或删除</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;readonly 与 shallowReadonly&lt;/h2&gt;</span><br><span class="line">  &lt;h3&gt;state:&#123;&#123; state2 &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;hr /&gt;</span><br><span class="line">  &lt;button @click=&quot;handleUpdata&quot;&gt;更新数据&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, reactive, readonly, ref, shallowReadonly &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &quot;&quot;,</span><br><span class="line">  setup(props, &#123; attrs, emit, slots &#125;) &#123;</span><br><span class="line">    const state = reactive(&#123;</span><br><span class="line">      name:&#x27;he&#x27;,</span><br><span class="line">      age:20,</span><br><span class="line">      car:&#123;</span><br><span class="line">        name:&#x27;红旗&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    // 只读数据---深度只读 对象的属性不能修改，对象的对象的属性也不能修改</span><br><span class="line">    // const state2 = readonly(state)</span><br><span class="line">    // 只读数据---浅度只读 对象的属性不能修改，对象的对象的属性可以修改</span><br><span class="line">    const state2 = JSON.parse(JSON.stringify(shallowReadonly(state)))</span><br><span class="line"></span><br><span class="line">    //  问题：state对象里的属性改变，也会影响state2对象里的属性(浅拷贝)</span><br><span class="line">    //  解决：JSON.parse(JSON.stringify(shallowReadonly(state))) 进行深拷贝</span><br><span class="line">    const handleUpdata = ()=&gt;&#123;</span><br><span class="line">      // state2.name += &#x27;==&#x27;</span><br><span class="line">      state2.car.name += &#x27;--&#x27;</span><br><span class="line">      console.log(state.car,state2.car);</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      state2,</span><br><span class="line">      state,</span><br><span class="line">      handleUpdata</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="toRaw-与-markRaw"><a href="#toRaw-与-markRaw" class="headerlink" title="toRaw 与 markRaw"></a><strong>toRaw 与 markRaw</strong></h1><ul>
<li>toRaw:把代理对象变成普通对象，数据变化，界面不变化</li>
<li>toRaw:返回由 reactive 或 readonly 方法转换成响应式代理的普通对象</li>
<li>markRaw:markRaw标记的对象,不能成为代理对象，数据不能在页面更新</li>
</ul>
<p><strong>markRaw应用场景:</strong><br><strong>有些值不应被设置为响应式的，例如复杂的第三方类实例或 Vue 组件对象。</strong><br><strong>当渲染具有不可变数据源的大列表时，跳过代理转换可以提高性能。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;toRaw 与 markRaw&lt;/h2&gt;</span><br><span class="line">  &lt;h3&gt;state:&#123;&#123; state &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;h3&gt;user1:&#123;&#123; user1 &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;h3&gt;user2:&#123;&#123; user2 &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;hr /&gt;</span><br><span class="line">  &lt;button @click=&quot;handleUpdata&quot;&gt;toRaw&lt;/button&gt;</span><br><span class="line">  &lt;button @click=&quot;handleUpdata1&quot;&gt;markRaw&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, markRaw, reactive, toRaw &#125; from &quot;vue&quot;;</span><br><span class="line">interface userInfo &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  car: any;</span><br><span class="line">  likes?: string[];</span><br><span class="line">&#125;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &quot;&quot;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const state = reactive&lt;userInfo&gt;(&#123;</span><br><span class="line">      name: &quot;he&quot;,</span><br><span class="line">      age: 20,</span><br><span class="line">      car: &#123;</span><br><span class="line">        name: &quot;红旗&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    // const user1:any = reactive(&#123;&#125;)</span><br><span class="line">    // const user2:any = reactive(&#123;&#125;)</span><br><span class="line">    const handleUpdata = () =&gt; &#123;</span><br><span class="line">      // 把代理对象变成普通对象，数据变化，界面不变化</span><br><span class="line">      const user1 = toRaw(state);</span><br><span class="line">      user1.name += &quot;==&quot;;</span><br><span class="line">      console.log(state, user1);</span><br><span class="line">    &#125;;</span><br><span class="line">    const handleUpdata1 = () =&gt; &#123;</span><br><span class="line">      // markRaw标记的对象,不能成为代理对象，数据不能在页面更新</span><br><span class="line">      const likes = [&quot;1&quot;];</span><br><span class="line">      state.likes = markRaw(likes);</span><br><span class="line">      setInterval(() =&gt; &#123;</span><br><span class="line">        if (state.likes) &#123;</span><br><span class="line">          state.likes[0] += &quot;0&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">      console.log(state);</span><br><span class="line"></span><br><span class="line">      // const user1 = JSON.parse(JSON.stringify(markRaw(state)));</span><br><span class="line">      // user1.name += &#x27;123&#x27;</span><br><span class="line">      // console.log(state);</span><br><span class="line">      // console.log(user1);</span><br><span class="line">      </span><br><span class="line">    &#125;;</span><br><span class="line">    return &#123;</span><br><span class="line">      state,</span><br><span class="line">      handleUpdata,</span><br><span class="line">      handleUpdata1,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a><strong>toRef</strong></h1><ul>
<li>为源响应式对象上的某个属性创建一个 ref 对象, 二者内部操作的是同一个数据值, 更新时二者是同步的</li>
<li><code>const age = toRef(state, &quot;age&quot;)</code></li>
<li>区别ref : 拷贝了一份新的数据值单独操作, 更新时相互不影响</li>
<li>应用: 当要将 某个 prop 的 ref 传递给复合函数时，toRef 很有用<blockquote>
<p>App.vue</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;toRef&lt;/h2&gt;</span><br><span class="line">  &lt;h3&gt;state:&#123;&#123; state &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;h3&gt;age:&#123;&#123; age &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;h3&gt;name:&#123;&#123; name &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;hr /&gt;</span><br><span class="line">  &lt;button @click=&quot;handleUpdata&quot;&gt;toRaw&lt;/button&gt;</span><br><span class="line">  &lt;Child :age=&#x27;age&#x27;&gt;&lt;/Child&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, reactive, toRef, ref &#125; from &quot;vue&quot;;</span><br><span class="line">import Child from &#x27;./components/Child.vue&#x27;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &quot;&quot;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const state = reactive(&#123;</span><br><span class="line">      name: &quot;he&quot;,</span><br><span class="line">      age: 20,</span><br><span class="line">      car: &#123;</span><br><span class="line">        name: &quot;红旗&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    // 把响应式数据state的属性age变成ref对象</span><br><span class="line">    const age = toRef(state, &quot;age&quot;);</span><br><span class="line">    // 把响应式数据state的属性name,使用ref进行包装，变成ref对象</span><br><span class="line">    const name = ref(state.name);</span><br><span class="line">    console.log(age,name);</span><br><span class="line">    </span><br><span class="line">    const handleUpdata = () =&gt; &#123;</span><br><span class="line">      state.age += 2</span><br><span class="line">      // name.value += 3</span><br><span class="line">    &#125;;</span><br><span class="line">    return &#123;</span><br><span class="line">      state,</span><br><span class="line">      age,</span><br><span class="line">      name,</span><br><span class="line">      handleUpdata,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Child.vue</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;Child组件，子组件&lt;/h2&gt;</span><br><span class="line">  &lt;h3&gt;age:&#123;&#123; age &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;h3&gt;length:&#123;&#123; length &#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; computed, defineComponent, Ref, ref, toRef &#125; from &quot;vue&quot;;</span><br><span class="line">// 参数必须是一个Ref类型的数据</span><br><span class="line">function useGetLength(age:Ref) &#123;</span><br><span class="line">  return computed(() =&gt; &#123;</span><br><span class="line">    return age.value.toString().length;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &quot;&quot;,</span><br><span class="line">  //   props: &#123;</span><br><span class="line">  //     age: &#123;</span><br><span class="line">  //       type: Number,</span><br><span class="line">  //       required: true,</span><br><span class="line">  //     &#125;,</span><br><span class="line">  //   &#125;,</span><br><span class="line">  props: [&quot;age&quot;],</span><br><span class="line">  setup(props, &#123; attrs, emit, slots &#125;) &#123;</span><br><span class="line">    //把一个对象里的属性，变成ref对象</span><br><span class="line">    const length = useGetLength(toRef(props, &quot;age&quot;));</span><br><span class="line">    console.log(length);</span><br><span class="line">    console.log(props);</span><br><span class="line">    return &#123;</span><br><span class="line">      length,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a><strong>customRef</strong></h1><ul>
<li>创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制</li>
</ul>
<p><strong>需求: 使用 customRef 实现 debounce 的示例</strong><br><strong>get: 告诉vue追踪数据:track() set: 告诉Vue更新页面:trigger()</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;customRef 的使用:自定义hook防抖的函数&lt;/h2&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&quot;keyword&quot; /&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; keyword &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; customRef, defineComponent, ref &#125; from &quot;vue&quot;;</span><br><span class="line">// 自定义hook防抖的函数</span><br><span class="line">// value传入的数据，将来数据的类型不确定，所以用泛型</span><br><span class="line">// num是防抖的间隔时间</span><br><span class="line">function UsecustomRef&lt;T&gt;(value: T, num=200) &#123;</span><br><span class="line">  // 准备一个存储定时器的id的变量</span><br><span class="line">  let timeoutId: number;</span><br><span class="line">  return customRef((track, trigger) =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      // 返回数据</span><br><span class="line">      get() &#123;</span><br><span class="line">        // 告诉vue追踪数据</span><br><span class="line">        track();</span><br><span class="line">        return value;</span><br><span class="line">      &#125;,</span><br><span class="line">      // 设置数据</span><br><span class="line">      set(newValue: T) &#123;</span><br><span class="line">        // 清理定时器</span><br><span class="line">        clearTimeout(timeoutId);</span><br><span class="line">        // 开启定时器</span><br><span class="line">        timeoutId = setTimeout(() =&gt; &#123;</span><br><span class="line">          value = newValue;</span><br><span class="line">          // 告诉Vue更新页面</span><br><span class="line">          trigger();</span><br><span class="line">        &#125;, num);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &quot;&quot;,</span><br><span class="line">  setup(props, &#123; attrs, emit, slots &#125;) &#123;</span><br><span class="line">    // const keyword = ref(&#x27;abc&#x27;)</span><br><span class="line">    const keyword = UsecustomRef(&quot;abc&quot;, 500);</span><br><span class="line">    return &#123;</span><br><span class="line">      keyword,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="provide-与-inject：父组件与孙子组件之间的通信"><a href="#provide-与-inject：父组件与孙子组件之间的通信" class="headerlink" title="provide 与 inject：父组件与孙子组件之间的通信"></a><strong>provide 与 inject：父组件与孙子组件之间的通信</strong></h1><p><strong>provide和inject提供依赖注入，功能类似 2.x 的provide/inject</strong><br><strong>实现跨层级组件(祖孙)间通信</strong></p>
<blockquote>
<p>App.vue(父组件)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;provide 与 inject&lt;/h2&gt;</span><br><span class="line">  &lt;p&gt;color:&#123;&#123;color&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;button @click=&quot;color = &#x27;yellow&#x27;&quot;&gt;黄&lt;/button&gt;</span><br><span class="line">  &lt;button @click=&quot;color = &#x27;green&#x27;&quot;&gt;绿&lt;/button&gt;</span><br><span class="line">  &lt;button @click=&quot;color = &#x27;blue&#x27;&quot;&gt;蓝&lt;/button&gt;</span><br><span class="line">  &lt;hr&gt;</span><br><span class="line">  &lt;Son&gt;&lt;/Son&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">// 实现夸子级组件，与孙子组件通信</span><br><span class="line">import &#123; defineComponent, ref,provide &#125; from &quot;vue&quot;;</span><br><span class="line">import Son from &quot;./components/Child.vue&quot;;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &quot;&quot;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    Son</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props, &#123; attrs, emit, slots &#125;) &#123;</span><br><span class="line">    // 响应式数据</span><br><span class="line">    const color = ref(&#x27;red&#x27;)</span><br><span class="line">    // provide</span><br><span class="line">    provide(&#x27;color&#x27;,color)</span><br><span class="line">    return &#123;</span><br><span class="line">      color</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Child.vue(子组件)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;子级组件&lt;/h2&gt;</span><br><span class="line">  &lt;hr /&gt;</span><br><span class="line">  &lt;Grandson&gt;&lt;/Grandson&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, ref &#125; from &quot;vue&quot;;</span><br><span class="line">import Grandson from &quot;./Grandson.vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &quot;Child&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Grandson,</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props, &#123; attrs, emit, slots &#125;) &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Grandson.vue(孙组件)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2 :style=&quot;&#123;color&#125;&quot;&gt;孙子组件&lt;/h2&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, inject &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &quot;Grandson&quot;,</span><br><span class="line">  setup(props, &#123; attrs, emit, slots &#125;) &#123;</span><br><span class="line">    const color = inject(&#x27;color&#x27;)</span><br><span class="line">    return &#123;</span><br><span class="line">      color</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="响应式数据的判断"><a href="#响应式数据的判断" class="headerlink" title="响应式数据的判断"></a><strong>响应式数据的判断</strong></h1><p><strong>isRef: 检查一个值是否为一个 ref 对象</strong><br><strong>isReactive: 检查一个对象是否是由 reactive 创建的响应式代理</strong><br><strong>isReadonly: 检查一个对象是否是由 readonly 创建的只读代理</strong><br><strong>isProxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;响应式数据的判断&lt;/h2&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123;</span><br><span class="line">  defineComponent,</span><br><span class="line">  ref,</span><br><span class="line">  isRef,</span><br><span class="line">  isReactive,</span><br><span class="line">  reactive,</span><br><span class="line">  isReadonly,</span><br><span class="line">  readonly,</span><br><span class="line">  isProxy,</span><br><span class="line">&#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &quot;&quot;,</span><br><span class="line">  // isRef isReactive isReadonly isProxy</span><br><span class="line">  setup(props, &#123; attrs, emit, slots &#125;) &#123;</span><br><span class="line">    // isRef: 检查一个值是否为一个 ref 对象,返回true or false</span><br><span class="line">    console.log(isRef(ref(0))); // true</span><br><span class="line">    // isReactive: 检查一个对象是否是由 reactive 创建的响应式代理,返回true or false</span><br><span class="line">    console.log(isReactive(reactive(&#123;&#125;))); // true</span><br><span class="line">    // isReadonly: 检查一个对象是否是由 readonly 创建的只读代理,返回true or false</span><br><span class="line">    const str = ref(&#x27;abc&#x27;) </span><br><span class="line">    const str1 = readonly(str)</span><br><span class="line">    console.log(&#x27;str:&#x27;,isReadonly(str1)); // true</span><br><span class="line">    // isProxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理</span><br><span class="line">    console.log(&quot;isProxy1:&quot;,isProxy(readonly(&#123;&#125;)));</span><br><span class="line">    console.log(&quot;isProxy2:&quot;,isProxy(reactive(&#123;&#125;)));</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue3基础</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3 手写组合 API</title>
    <url>/2021/12/14/vue3_a_4/</url>
    <content><![CDATA[<blockquote>
<p>index.html </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script text=&quot;text/javascript&quot;&gt;</span><br><span class="line">        let proxyUser1 = shallowReactive(&#123;</span><br><span class="line">            name: &#x27;he&#x27;,</span><br><span class="line">            age: 32,</span><br><span class="line">            car: &#123;</span><br><span class="line">                color: &#x27;blue&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        // set</span><br><span class="line">        // 拦截了修改数据或添加属性 name true</span><br><span class="line">        // proxyUser1.name = &#x27;小红&#x27;</span><br><span class="line"></span><br><span class="line">        // get set</span><br><span class="line">        // 拦截了读取数据 name he</span><br><span class="line">        // 拦截了修改数据或添加属性 name true</span><br><span class="line">        // proxyUser1.name += &#x27;==&#x27;</span><br><span class="line"></span><br><span class="line">        // 只拦截到读取数据，没有拦截到修改数据【只拦截get,拦截不到set】</span><br><span class="line">        // 拦截了读取数据 car &#123;color: &#x27;blue&#x27;&#125;</span><br><span class="line">        // proxyUser1.car.color += &#x27;==&#x27;</span><br><span class="line">        // 拦截了删除数据</span><br><span class="line">        // delete proxyUser1.name</span><br><span class="line">        // 拦截get,拦截不了删除数据 【浅的监视，浅的劫持】</span><br><span class="line">        // delete proxyUser1.car.color</span><br><span class="line"></span><br><span class="line">        let proxyUser2 = Reactive(&#123;</span><br><span class="line">            name: &#x27;he&#x27;,</span><br><span class="line">            age: 32,</span><br><span class="line">            car: &#123;</span><br><span class="line">                color: &#x27;blue&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        // get【拦截了读取数据car,以及car的属性color】set:拦截了修改数据或添加属性</span><br><span class="line">        // proxyUser2.car.color += &#x27;==&#x27;</span><br><span class="line">        // 拦截了读取数据  拦截了删除数据 </span><br><span class="line">        // delete proxyUser2.car.color</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        //  ==========================================</span><br><span class="line"></span><br><span class="line">        // 测试 shallowReadonly 与 readonly</span><br><span class="line">        let readonly1 = shallowReadonly(&#123;</span><br><span class="line">            name: &#x27;小明&#x27;,</span><br><span class="line">            age: 12,</span><br><span class="line">            boll: &#123;</span><br><span class="line">                color: &#x27;blue&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        // 只能读取数据,不能修改数据</span><br><span class="line">        // readonly1.name  = &#x27;小刘&#x27;</span><br><span class="line">        // 深层可以修改</span><br><span class="line">        // readonly1.boll.color = &#x27;red&#x27;</span><br><span class="line">           // 只能读取数据,不能删除数据</span><br><span class="line">        // delete readonly1.name </span><br><span class="line"></span><br><span class="line">        // 可以修改深层数据</span><br><span class="line">        // readonly1.boll.color = &#x27;red&#x27;</span><br><span class="line">        // delete readonly1.boll.color</span><br><span class="line">        // console.log(readonly1);</span><br><span class="line"></span><br><span class="line">        let readonly2 = readonly(&#123;</span><br><span class="line">            name: &#x27;小明&#x27;,</span><br><span class="line">            age: 12,</span><br><span class="line">            boll: &#123;</span><br><span class="line">                color: &#x27;blue&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        //  不可以修改深层数据</span><br><span class="line">        // readonly2.boll.color = &#x27;red&#x27;</span><br><span class="line">        // delete readonly2.boll.color</span><br><span class="line">        // console.log(readonly2);</span><br><span class="line"></span><br><span class="line">        let refData1 = shallowRef(&#123;</span><br><span class="line">            name: &#x27;李白&#x27;,</span><br><span class="line">            age: 45,</span><br><span class="line">            car: [&#x27;奔驰&#x27;,&#x27;宝马&#x27;]</span><br><span class="line">        &#125;)</span><br><span class="line">        // refData1.value</span><br><span class="line">        // 深层数据变化，不能劫持到【深层数据变化，不能实现数据响应式】</span><br><span class="line">        // refData1.value.age = &#x27;--&#x27;</span><br><span class="line">        // console.log(refData1);</span><br><span class="line"></span><br><span class="line">        let refData2 = Ref(&#123;</span><br><span class="line">            name: &#x27;李白&#x27;,</span><br><span class="line">            age: 45,</span><br><span class="line">            car: [&#x27;奔驰&#x27;,&#x27;宝马&#x27;]</span><br><span class="line">        &#125;)</span><br><span class="line">        // 深层数据变化，能劫持到【深层数据变化，也能实现数据响应式】</span><br><span class="line">        // refData2.value.car[0] = &#x27;--&#x27;</span><br><span class="line">        // console.log(refData2);</span><br><span class="line"></span><br><span class="line">        // =====================================</span><br><span class="line">        // console.log(isRef(Ref(&#123;&#125;)));</span><br><span class="line">        // console.log(isReactive(Reactive(&#123;&#125;)));</span><br><span class="line">        // console.log(isReadonly(readonly(&#123;&#125;)));</span><br><span class="line">        // console.log(isProxy(Reactive(&#123;&#125;)));</span><br><span class="line">        console.log(isProxy(readonly(&#123;&#125;)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>index.js</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// shallowReactive(浅的监视，浅的劫持，浅的响应数据) 与 reactive(深的)</span><br><span class="line">// shallowReadonly 与 readonly</span><br><span class="line">// shallowRef 与 ref</span><br><span class="line">// isRef, isReactive 与 isReadonly isProxy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 定义一个handle对象</span><br><span class="line">let handler = &#123;</span><br><span class="line">    // Reflect.get()方法与从对象 ( target[propertyKey]) 中读取属性类似，</span><br><span class="line">    // 但它是通过一个函数执行来操作的。</span><br><span class="line">    // Reflect.get方法允许你从一个对象中取属性值</span><br><span class="line">    // Reflect.set 方法允许你在对象上设置属性</span><br><span class="line"></span><br><span class="line">    get(target, prop) &#123;</span><br><span class="line">        if(prop === &#x27;_is_reactive&#x27;) return true</span><br><span class="line">        let result = Reflect.get(target, prop)</span><br><span class="line">        console.log(&#x27;拦截了读取数据&#x27;, prop, result);</span><br><span class="line">        return result</span><br><span class="line">    &#125;,</span><br><span class="line">    // prop：将被设置的属性名或Symbol。 value：新属性值</span><br><span class="line">    set(target, prop, value) &#123;</span><br><span class="line">        let result = Reflect.set(target, prop, value);</span><br><span class="line">        console.log(&#x27;拦截了修改数据或添加属性&#x27;, prop, result);</span><br><span class="line">        return result</span><br><span class="line">    &#125;,</span><br><span class="line">    //  target:目标对象 property:待删除的属性名</span><br><span class="line">    // deleteProperty必须返回一个Boolean类型的值，表示该属性是否被成功删除</span><br><span class="line">    deleteProperty(target, prop) &#123;</span><br><span class="line">        let result = Reflect.deleteProperty(target, prop)</span><br><span class="line">        console.log(&#x27;拦截了删除数据&#x27;, prop, result);</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义一个 shallowReactive 函数，传入一个目标对象</span><br><span class="line">function shallowReactive(target) &#123;</span><br><span class="line">    // 判断target类型是不是一个object类型（可能会传普通数据）</span><br><span class="line">    // target instanceof Object</span><br><span class="line">    if (target &amp;&amp; typeof target === &#x27;object&#x27;) &#123;</span><br><span class="line">        return new Proxy(target, handler)</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果是基本数据类型，直接返回</span><br><span class="line">    return target</span><br><span class="line">&#125;</span><br><span class="line">// 定义一个 reactive 函数，传入一个目标对象</span><br><span class="line">function Reactive(target) &#123;</span><br><span class="line">    if (target &amp;&amp; typeof target === &#x27;object&#x27;) &#123;</span><br><span class="line">        // 对数组或是对象中所有的数据进行 reactive 的递归处理（原因：reactive是深度响应式数据）</span><br><span class="line">        // 1. 当前的数据是不是数组</span><br><span class="line">        // Array.isArray(target)</span><br><span class="line">        if (target instanceof Array) &#123;</span><br><span class="line">            target.forEach((item, index) =&gt; &#123;</span><br><span class="line">                target[index] = Reactive(item)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 2.再判断当前的数据是不是对象</span><br><span class="line">            // 对象的数据也要进行遍历操作</span><br><span class="line">            Object.keys(target).forEach(key =&gt; &#123;</span><br><span class="line">                target[key] = Reactive(target[key])</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        return new Proxy(target, handler)</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果是基本数据类型，直接返回</span><br><span class="line">    return target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  =============================</span><br><span class="line">// 定义一个handlerReadonly 处理器</span><br><span class="line">let handlerReadonly = &#123;</span><br><span class="line">    get(target, prop) &#123;</span><br><span class="line">        if(prop === &#x27;_is_readonly&#x27;) return true</span><br><span class="line">        let result = Reflect.get(target, prop)</span><br><span class="line">        console.log(&#x27;Readonly：拦截了读取数据&#x27;, prop, result);</span><br><span class="line">        return result</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, prop, value) &#123;</span><br><span class="line">        // let result = Reflect.set(target, prop, value);</span><br><span class="line">        console.warn(&#x27;只能读取数据,不能修改数据&#x27;);</span><br><span class="line">        return true</span><br><span class="line">    &#125;,</span><br><span class="line">    deleteProperty(target, prop) &#123;</span><br><span class="line">        // let result = Reflect.deleteProperty(target, prop)</span><br><span class="line">        console.warn(&#x27;只能读取数据,不能删除数据&#x27;);</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义一个 shallowReadonly 函数</span><br><span class="line">function shallowReadonly(target) &#123;</span><br><span class="line">    if (target &amp;&amp; typeof target === &#x27;object&#x27;) &#123;</span><br><span class="line">        return new Proxy(target, handlerReadonly)</span><br><span class="line">    &#125;</span><br><span class="line">    return target</span><br><span class="line">&#125;</span><br><span class="line">// 定义一个 readonly 函数</span><br><span class="line">function readonly(target) &#123;</span><br><span class="line">    if (target &amp;&amp; typeof target === &#x27;object&#x27;) &#123;</span><br><span class="line">        if (target instanceof Array) &#123;</span><br><span class="line">            target.forEach((item, index) =&gt; &#123;</span><br><span class="line">                // 递归处理item</span><br><span class="line">                target[index] = readonly(item)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Object.keys(target).forEach(key =&gt; &#123;</span><br><span class="line">                target[key] = readonly(target[key])</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        return new Proxy(target, handlerReadonly)</span><br><span class="line">    &#125;</span><br><span class="line">    return target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ==========================================</span><br><span class="line"></span><br><span class="line">// 定义一个 shallowRef 函数</span><br><span class="line">function shallowRef(target) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        // 保存target</span><br><span class="line">        _value: target,</span><br><span class="line">        get value() &#123;</span><br><span class="line">            console.log(&#x27;劫持到读取数据&#x27;);</span><br><span class="line">            return this._value</span><br><span class="line">        &#125;,</span><br><span class="line">        set value(val) &#123;</span><br><span class="line">            console.log(&#x27;劫持到修改数据,准备更新界面&#x27;,val);</span><br><span class="line">            this._value = val</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 定义一个 Ref 函数</span><br><span class="line">function Ref(target) &#123;</span><br><span class="line">    target = Reactive(target)</span><br><span class="line">    </span><br><span class="line">    return &#123;</span><br><span class="line">        _is_ref:true, //标识当前对象为ref对象</span><br><span class="line">        // 保存target</span><br><span class="line">        _value: target,</span><br><span class="line">        get value() &#123;</span><br><span class="line">            console.log(&#x27;劫持到读取数据&#x27;);</span><br><span class="line">            return this._value</span><br><span class="line">        &#125;,</span><br><span class="line">        set value(val) &#123;</span><br><span class="line">            console.log(&#x27;劫持到修改数据,准备更新界面&#x27;,val);</span><br><span class="line">            this._value = val</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// ==========================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 定义一个 isRef ，判断当前的对象是不是 ref 对象</span><br><span class="line">function isRef(obj) &#123;</span><br><span class="line">    return obj &amp;&amp; obj._is_ref</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">// 定义一个 isReactive ，判断当前的对象是不是 reactive 对象</span><br><span class="line">function isReactive(obj) &#123;</span><br><span class="line">    return obj &amp;&amp; obj._is_reactive</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">// 定义一个 isReadonly ，判断当前的对象是不是 readonly 对象</span><br><span class="line">function isReadonly(obj) &#123;</span><br><span class="line">    return obj &amp;&amp; obj._is_readonly</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">// 定义一个 isProxy ，判断当前的对象是不是 readonly 对象 或 reactive 对象</span><br><span class="line">function isProxy(obj) &#123;</span><br><span class="line">    return isReactive(obj) || isReadonly(obj)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue3基础</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3 其它新组合和API</title>
    <url>/2021/12/14/vue3_a_5/</url>
    <content><![CDATA[<h1 id="Fragment-片断"><a href="#Fragment-片断" class="headerlink" title="Fragment(片断)"></a><strong>Fragment(片断)</strong></h1><p><strong>好处: 减少标签层级, 减小内存占用</strong></p>
<ul>
<li>在 Vue2 中: 组件必须有一个根标签</li>
<li>在 Vue3 中: 组件可以没有根标签, 内部会将多个标签包含在一个 Fragment 虚拟元素中</li>
</ul>
<p><strong>不能使用的原因： 1.查看是否安装了Vetur插件 2.文件=&gt;首选项=&gt;设置 3.进入设置页搜索 eslint 把Vetur的验证模板，取消勾选Validate vue-html in using eslint-plugin-vue</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// vue3</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;aaaa&lt;/h2&gt;</span><br><span class="line">  &lt;h2&gt;aaaa&lt;/h2&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// vue2</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;!-- 根标签 --&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Teleport-瞬移"><a href="#Teleport-瞬移" class="headerlink" title="Teleport(瞬移)"></a><strong>Teleport(瞬移)</strong></h1><p><strong>Teleport 提供了一种干净的方法, 让组件的 html 在父组件界面外的特定标签(很可能是 body)下插入显示</strong></p>
<blockquote>
<p>App.vue</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;APP父级组件&lt;/h2&gt;</span><br><span class="line">  &lt;modalOpen /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, ref &#125; from &quot;vue&quot;;</span><br><span class="line">import modalOpen from &quot;./ModalButton.vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &quot;&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    modalOpen,</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props, &#123; attrs, emit, slots &#125;) &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ModalButton.vue</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;modalOpen = true&quot;&gt;打开对话框&lt;/button&gt;</span><br><span class="line">  &lt;!-- 对话框代码 --&gt;</span><br><span class="line">  &lt;Teleport to=&quot;body&quot;&gt;</span><br><span class="line">    &lt;div v-if=&quot;modalOpen&quot; class=&quot;modal&quot;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        这是对话框</span><br><span class="line">        &lt;button @click=&quot;modalOpen = false&quot;&gt;关闭对话框&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/Teleport&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, ref &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &quot;&quot;,</span><br><span class="line">  setup(props, &#123; attrs, emit, slots &#125;) &#123;</span><br><span class="line">    //   控制对话框显示隐藏</span><br><span class="line">    const modalOpen = ref(false);</span><br><span class="line">    return &#123;</span><br><span class="line">      modalOpen,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.modal &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  background-color: rgba(0, 0, 0, 0.5);</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">  align-items: center;</span><br><span class="line">  justify-content: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.modal div &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">  align-items: center;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  background-color: white;</span><br><span class="line">  width: 300px;</span><br><span class="line">  height: 300px;</span><br><span class="line">  padding: 5px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<h1 id="Suspense-不确定的"><a href="#Suspense-不确定的" class="headerlink" title="Suspense(不确定的)"></a><strong>Suspense(不确定的)</strong></h1><p><strong>它们允许我们的应用程序在等待异步组件时渲染一些后备内容，可以让我们创建一个平滑的用户体验</strong><br><strong>作用：在一个异步组件加载的过程中，显示其他内容，不使用长时间显示空白界面</strong></p>
<blockquote>
<p>App.vue</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;App父级组件：Suspense&lt;/h2&gt;</span><br><span class="line">  &lt;Suspense&gt;</span><br><span class="line">    &lt;template #default&gt;</span><br><span class="line">      &lt;!-- 放入一个异步组件 --&gt;</span><br><span class="line">      &lt;!-- &lt;Async&gt;&lt;/Async&gt; --&gt;</span><br><span class="line">      &lt;Async1&gt;&lt;/Async1&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;template v-slot:fallback&gt;</span><br><span class="line">      &lt;!-- 准备的内容 --&gt;</span><br><span class="line">      &lt;h2&gt;Loading&lt;/h2&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/Suspense&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">// 引入组件 ：静态引入 和动态引入</span><br><span class="line">// vue2的动态引入组件的写法：(在vue3中，这种写法不行)</span><br><span class="line">// const Async = () =&gt; import(&quot;./Async.vue&quot;)</span><br><span class="line">// vue3的动态引入组件的写法：</span><br><span class="line">// const Async = defineAsyncComponent(() =&gt; import(&quot;./Async.vue&quot;));</span><br><span class="line">// 静态引入</span><br><span class="line">// import Async from &quot;./Async.vue&quot;</span><br><span class="line">import Async1 from &quot;./Async1.vue&quot;</span><br><span class="line"></span><br><span class="line">import &#123; defineAsyncComponent, defineComponent, ref &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &quot;&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    // Async,</span><br><span class="line">    Async1,</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props, &#123; attrs, emit, slots &#125;) &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Async.vue</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;Async子级组件&lt;/h2&gt;</span><br><span class="line">  &lt;h3&gt;&#123;&#123;msg&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, ref &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &quot;&quot;,</span><br><span class="line">  setup(props, &#123; attrs, emit, slots &#125;) &#123;</span><br><span class="line">      return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        setTimeout(()=&gt;&#123;</span><br><span class="line">          resolve(&#123;</span><br><span class="line">            msg:&#x27;123456789&#x27;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;,2000)</span><br><span class="line">      &#125;)</span><br><span class="line">    // return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Async1.vue</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;Async1组件&lt;/h2&gt;</span><br><span class="line">  &lt;h3&gt;&#123;&#123; data &#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, ref &#125; from &quot;vue&quot;;</span><br><span class="line">import axios from &quot;axios&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &quot;&quot;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">      return axios.get(&#x27;/data/address.json&#x27;).then(response =&gt;&#123;</span><br><span class="line">          return &#123;</span><br><span class="line">              data:response.data</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;).catch()</span><br><span class="line">    &#125;,</span><br><span class="line">//   async setup() &#123;</span><br><span class="line">//     const result = await axios.get(&quot;/data/address.json&quot;);</span><br><span class="line">//     return &#123;</span><br><span class="line">//         data:result.data</span><br><span class="line">//     &#125;</span><br><span class="line">//   &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>public/data/address.json</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;:1,</span><br><span class="line">    &quot;address&quot;:&quot;四川省成都市二仙桥&quot;,</span><br><span class="line">    &quot;distance&quot;:&quot;200m&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="其他新的-API"><a href="#其他新的-API" class="headerlink" title="其他新的 API"></a><strong>其他新的 API</strong></h1><p><strong>1. 全新的全局 API</strong></p>
<ul>
<li>createApp()</li>
<li>defineProperty()</li>
<li>defineAsyncComponent()</li>
<li>nextTick()</li>
</ul>
<p><strong>2. 将原来的全局 API 转移到应用对象</strong></p>
<ul>
<li>app.component()</li>
<li>app.config()</li>
<li>app.directive()</li>
<li>app.mount()</li>
<li>app.unmount()</li>
<li>app.use()</li>
</ul>
<p><strong>3. 模板语法变化</strong></p>
<ul>
<li>v-model 的本质变化<ul>
<li>prop：value -&gt; modelValue；</li>
<li>event：input -&gt; update:modelValue；</li>
</ul>
</li>
<li>sync 修改符已移除, 由 v-model 代替<ul>
<li><code>&lt;ChildComponent v-model:title=&quot;pageTitle&quot; v-model:content=&quot;pageContent&quot; /&gt;</code></li>
</ul>
</li>
<li>v-if 优先 v-for 解析</li>
</ul>
<h1 id="对vue3的了解"><a href="#对vue3的了解" class="headerlink" title="对vue3的了解"></a><strong>对vue3的了解</strong></h1><ul>
<li>2020年9月发布正式版</li>
<li>vue3支持大多数vue2的特性</li>
<li>vue3设计了一套强大的组合API代替vue2中的option API,复用性更强</li>
<li>更好的支持了Ts</li>
<li>vue3使用了Proxy配合Reflect 代替了vue2中的Object.defineProperty()方式实现数据的响应式（数据代理）</li>
<li>重写了虚拟DOM,速度更快了</li>
<li>新的组件：Fragment(片段) / Teleport(瞬移) /Susperse(不确定)</li>
<li>设计了一个新的脚手架工具 vite </li>
</ul>
]]></content>
      <categories>
        <category>Vue3基础</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue数据代理劫持底层原理</title>
    <url>/2021/09/06/vue_a_1/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let data = &#123;</span><br><span class="line">    username:&#x27;zhangsan&#x27;,</span><br><span class="line">    age:18</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 模拟组件实例</span><br><span class="line">//通过object.defindproprety来实现数据劫持代理</span><br><span class="line">let _this = &#123;</span><br><span class="line">    test:123</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(let i in data)&#123;</span><br><span class="line">    console.log(i,data[i])</span><br><span class="line">    //参数：目标对象，添加的属性（键）,值</span><br><span class="line">    Object.defineProperty(_this,i,&#123;</span><br><span class="line">        //get作用： 获取扩展属性值,当获取该属性值的时候，调用get方法</span><br><span class="line">        get() &#123;</span><br><span class="line">            console.log(&#x27;get调用&#x27;)</span><br><span class="line">            return data[i]</span><br><span class="line">        &#125;,</span><br><span class="line">        //set作用：监视扩展属性的值，只要修改就调用</span><br><span class="line">        //注意：不能在set方法里做修改扩展属性值，会陷入死循环 【_this.age = value】</span><br><span class="line">        //再次通过修改data里的属性值，来改变_this</span><br><span class="line">        set(value)&#123;</span><br><span class="line">            console.log(&#x27;set调用&#x27;,value)</span><br><span class="line">            // data.age = value</span><br><span class="line">            data[i] = value</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">//通过Object.defineProperty()，获取的扩展属性不能直接修改，但会触发set()方法</span><br><span class="line">_this.age = 20</span><br><span class="line">console.log(_this)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue基础</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue基础巩固（一）</title>
    <url>/2021/11/06/vue_a_2/</url>
    <content><![CDATA[<blockquote>
<p><strong>1.为什么data里要加return？</strong><br>不使用return包裹数据会在全局可见，造成变量污染<br>只在当前组件中生效，不会影响其他组件</p>
</blockquote>
<blockquote>
<p><strong>2.vue有哪些指令？</strong><br>v-once:表示元素和组件只渲染一次<br>v-html:解析出HTML展示【一般是string类型】<br>v-text:将数据显示在界面中【与插值表达式相似】【一般是string类型】<br>v-pre:跳过这个元素和它子元素的编译过程【不进行编译】<br>v-cloak:当网络较慢，网页还在加载 Vue.js ，而导致 Vue 来不及渲染，这时页面就会显示出 Vue 源代码【解决屏幕闪动的问题】【在大型、工程化项目webpack、vue-router中用不到，元素中的内容是通过路由挂载来实现的】<br>v-bind:动态绑定属性</p>
</blockquote>
<blockquote>
<p><strong>3.计算属性</strong><br><strong>计算属性的setter和getter:每个计算属性都包含一个getter和一个setter,一般是使用使用getter来读取【图2】</strong><br><img src="/images/computed.png" alt="计算属性"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">       &lt;h1&gt;&#123;&#123;totalPrice&#125;&#125;&lt;/h1&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script&gt;</span><br><span class="line">       </span><br><span class="line">       let app = new Vue(&#123;</span><br><span class="line">           el:&#x27;#app&#x27;,</span><br><span class="line">           data:&#123;</span><br><span class="line">               books:[</span><br><span class="line">                   &#123;name:&#x27;js&#x27;,price:21,count:3&#125;,</span><br><span class="line">                   &#123;name:&#x27;vue&#x27;,price:3,count:1&#125;,</span><br><span class="line">                   &#123;name:&#x27;html&#x27;,price:2,count:2&#125;,</span><br><span class="line">               ]</span><br><span class="line">           &#125;,</span><br><span class="line">           computed:&#123;</span><br><span class="line">               totalPrice()&#123;</span><br><span class="line">                   // 1.for()</span><br><span class="line">                   // let num =0</span><br><span class="line">                   // for(let i = 0;i&lt;this.books.length;i++)&#123;</span><br><span class="line">                   //     num += this.books[i].price * this.books[i].count</span><br><span class="line">                   // &#125;</span><br><span class="line">                   // return num</span><br><span class="line"></span><br><span class="line">                   // 2.reduce()</span><br><span class="line">                   // return this.books.reduce((total,b)=&gt;&#123;</span><br><span class="line">                   //     return total + b.price * b.count</span><br><span class="line">                   // &#125;,0)</span><br><span class="line"></span><br><span class="line">                   // 3. forEach()</span><br><span class="line">                   // let num = 0</span><br><span class="line">                   // this.books.forEach(item =&gt; &#123;</span><br><span class="line">                   //     num += item.price * item.count</span><br><span class="line">                   // &#125;)</span><br><span class="line">                   // return num</span><br><span class="line"></span><br><span class="line">                   // 4. map()</span><br><span class="line">                   // let num = 0</span><br><span class="line">                   // this.books.map(item =&gt; &#123;</span><br><span class="line">                   //     num += item.price * item.count</span><br><span class="line">                   //     console.log(num)</span><br><span class="line">                   // &#125;)</span><br><span class="line">                   // return num</span><br><span class="line"></span><br><span class="line">                   // JSON.parse(JSON.stringify(this.books))</span><br><span class="line">                   let notebook = JSON.parse(JSON.stringify(this.books))</span><br><span class="line">                   notebook.map(item =&gt; &#123;</span><br><span class="line">                       item.price = 10</span><br><span class="line">                   &#125;)</span><br><span class="line">                   console.log(notebook)</span><br><span class="line">                   console.log(this.books)</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">   &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/images/computed_01.png" alt="计算属性"></p>
<blockquote>
<p>3.1 <strong>计算属性的缓存：计算属性会进行缓存，如果多次使用时，计算属性只会调用一次</strong></p>
</blockquote>
</blockquote>
<blockquote>
<p><strong>4.v-on:绑定事件监听器 简写：@</strong><br>1.如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去<br>2.如果需要同时传入某个参数，同时需要event时，可以通过$event传入事件:<br><code>&lt;div @click=&quot;handleNum(10,$event)&quot;&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt; </code><br>3.动态指令<br><code>&lt;div v-bind:[attributeName]=&quot;color&quot;&gt;&lt;/div&gt;</code><br><code>&lt;button @[eventName]=&quot;handlechange&quot;&gt;切换颜色&lt;/button&gt;</code><br>4.v-on修饰符:<br>.stop - 调用 event.stopPropagation():停止冒泡<br>.prevent - 调用 event.preventDefault():阻止默认行为<br>.native - 监听组件根元素的原生事件<br>.{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调<br>.once - 只触发一次回调<br><img src="/images/v-on.png" alt="v-on修饰符"></p>
</blockquote>
<blockquote>
<p><strong>5.v-if、v-else-if、v-else</strong></p>
<blockquote>
<p><strong>v-if和v-show的区别？</strong><br>1.v-if条件为false，对应的元素以及其子元素不会渲染，DOM中不会有对应的标签<br>2.v-show条件为false，对应的元素以及其子元素不会渲染，DOM中有对应的标签，元素的display属性设置为none<br>用法：需要在显示与隐藏之间切片很频繁时，使用v-show ，只有一次切换时，通过使用v-if</p>
</blockquote>
</blockquote>
<blockquote>
<p><strong>有输入内容的情况下，切换了类型，为什么文字依然显示之前的输入的内容?</strong><br>因为Vue在进行DOM渲染时，出于性能考虑，会尽可能的复用已经存在的元素，而不是重新创建新的元素<br>解决：不希望Vue出现类似重复利用的问题，可以给对应的input添加key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">       &lt;span v-if=&quot;type&quot;&gt;</span><br><span class="line">           &lt;label&gt;用户账号：&lt;/label&gt;</span><br><span class="line">           &lt;input type=&quot;text&quot; placeholder=&quot;用户账号&quot; key=&quot;username&quot;&gt;</span><br><span class="line">       &lt;/span&gt;</span><br><span class="line">       &lt;span v-else&gt;</span><br><span class="line">           &lt;label&gt;用户密码：&lt;/label&gt;</span><br><span class="line">           &lt;input type=&quot;text&quot; placeholder=&quot;用户密码&quot; key=&quot;password&quot;&gt;</span><br><span class="line">       &lt;/span&gt;</span><br><span class="line">   &lt;button @click=&quot;handleChange&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&gt;&lt;/div&gt;</span><br><span class="line">&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&gt;&lt;script&gt;</span><br><span class="line"></span><br><span class="line">   let app = new Vue(&#123;</span><br><span class="line">       el: &#x27;#app&#x27;,</span><br><span class="line">       data: &#123;</span><br><span class="line">           type: true</span><br><span class="line">       &#125;,</span><br><span class="line">       methods: &#123;</span><br><span class="line">           handleChange() &#123;</span><br><span class="line">               this.type = !this.type</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>6.组件的key属性:使用key来给每个节点做一个唯一标识</strong><br><strong>作用：为了高效的更新虚拟DOM</strong><br><strong>使用后Diff算法就可以正确的识别此节点</strong></p>
</blockquote>
<blockquote>
<p><strong>声明式渲染和命令式渲染</strong><br>1.声明式:定义一个变量，使用双大括号插入变量<br>2.命令式:<code>document。querySelector(&#39;h1&#39;).innerHTML = &#39;hello&#39;</code></p>
</blockquote>
<blockquote>
<p><strong>在模板语法里使用JS表达式</strong><br>split(‘’):把一个字符串分割成字符串数组  reverse():反转数组中元素的顺序 join():把数组中的所有元素放入一个字符串<br><code>&lt;div&gt;&#123;&#123;msg.split('').reverse().jion()&#125;&#125;&lt;/div&gt;</code></p>
</blockquote>
<p>** Vue基础巩固（一）：** &lt;Excerpt in index | 首页摘要&gt;</p>
<span id="more"></span>
<p>&lt;The rest of contents | 余下全文&gt;</p>
]]></content>
      <categories>
        <category>Vue基础</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue基础巩固（二）</title>
    <url>/2021/11/11/vue_a_3/</url>
    <content><![CDATA[<blockquote>
<p><strong>1.认识组件化</strong><br>组件化思想:将页面拆分成一个个小的、可复用的组件</p>
</blockquote>
<blockquote>
<p><strong>2.注册组件</strong><br><strong>组件模板只包含一个根元素</strong><br><strong>组件不能直接访问Vue实例中的data</strong><br><strong>组件对象也有一个data属性,data属性必须是一个函数,这个函数返回一个对象，对象内部保存着数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">   &lt;!-- 3.使用组件 --&gt;</span><br><span class="line">   &lt;my-cpn&gt;&lt;/my-cpn&gt;</span><br><span class="line">&gt;&lt;/div&gt;</span><br><span class="line">&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&gt;&lt;script&gt;</span><br><span class="line">   // 1.创建组件构造器</span><br><span class="line">   const myComponent = Vue.extend(&#123;</span><br><span class="line">       template:`</span><br><span class="line">       &lt;div&gt;</span><br><span class="line">       &lt;h2&gt;组件标题111&lt;/h2&gt;</span><br><span class="line">       &lt;p&gt;组件内容&lt;/p&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">       `</span><br><span class="line">   &#125;)</span><br><span class="line">   // 2.注册组件，定义组件标签名</span><br><span class="line">   Vue.component(&#x27;my-cpn&#x27;,myComponent)</span><br><span class="line"></span><br><span class="line">   let app = new Vue(&#123;</span><br><span class="line">       el: &#x27;#app&#x27;,</span><br><span class="line">   &#125;)</span><br><span class="line">&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><strong>为什么data在组件中必须是一个函数?</strong><br>1.如果不是一个函数，Vue直接就会报错<br>2.Vue让每个组件对象都返回一个新的对象，因为如果是同一个对象的，组件在多次使用后会相互影响</p>
</blockquote>
<blockquote>
<p><strong>3.父子组件间的通信</strong></p>
<blockquote>
<p><strong>3.1 props用于父组件向子组件传递数据</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">   &lt;my-cpn :msg=&quot;msg&quot;&gt;&lt;/my-cpn&gt;</span><br><span class="line">&gt;&lt;/div&gt;</span><br><span class="line">&gt;&lt;template id=&quot;myCpn&quot;&gt;</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">       &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line">       &lt;div&gt;&#123;&#123;msg1&#125;&#125;&lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&gt;&lt;/template&gt;</span><br><span class="line">&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&gt;&lt;script&gt;</span><br><span class="line">   let app = new Vue(&#123;</span><br><span class="line">       el: &#x27;#app&#x27;,</span><br><span class="line">       data:&#123;</span><br><span class="line">           msg:&#x27;我是vue实例数据或父组件里的数据&#x27;</span><br><span class="line">       &#125;,</span><br><span class="line">       components:&#123;</span><br><span class="line">           &#x27;my-cpn&#x27;:&#123;</span><br><span class="line">               template: &#x27;#myCpn&#x27;,</span><br><span class="line">               props:[&#x27;msg&#x27;],</span><br><span class="line">               data()&#123;</span><br><span class="line">                   return&#123;</span><br><span class="line">                       msg1:&#x27;组件里的数据&#x27;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;,</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>3.2 通过自定义事件向父组件发送消息</strong><br>自定义事件的流程:<br>1.在子组件中，通过$emit()来触发事件【this.emit方法不能使用驼峰命名的函数】<br>2.在父组件中，通过v-on来监听子组件事件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">   &lt;my-cpn @increment=&quot;handleChange&quot; @decrement=&quot;handleChange&quot;&gt;&lt;/my-cpn&gt;</span><br><span class="line">   &lt;h2 &gt;点击次数：&#123;&#123;total&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&gt;&lt;/div&gt;</span><br><span class="line">&gt;&lt;template id=&quot;myCpn&quot;&gt;</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">       &lt;button @click=&quot;Increment&quot;&gt;+1&lt;/button&gt;</span><br><span class="line">       &lt;button @click=&quot;Decrement&quot;&gt;-1&lt;/button&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&gt;&lt;/template&gt;</span><br><span class="line">&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&gt;&lt;script&gt;</span><br><span class="line">   let app = new Vue(&#123;</span><br><span class="line">       el: &#x27;#app&#x27;,</span><br><span class="line">       data:&#123;</span><br><span class="line">           total:0</span><br><span class="line">       &#125;,</span><br><span class="line">       methods:&#123;</span><br><span class="line">           handleChange(count)&#123;</span><br><span class="line">               this.total = count</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       components:&#123;</span><br><span class="line">           &#x27;my-cpn&#x27;:&#123;</span><br><span class="line">               template: &#x27;#myCpn&#x27;,</span><br><span class="line">               props:[&#x27;msg&#x27;],</span><br><span class="line">               data()&#123;</span><br><span class="line">                   return&#123;</span><br><span class="line">                       count:0</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;,</span><br><span class="line">               methods:&#123;</span><br><span class="line">                   Increment()&#123;</span><br><span class="line">                       this.count++</span><br><span class="line">                       this.$emit(&#x27;increment&#x27;,this.count)</span><br><span class="line">                   &#125;,</span><br><span class="line">                   Decrement()&#123;</span><br><span class="line">                       this.count--</span><br><span class="line">                       this.$emit(&#x27;decrement&#x27;,this.count)</span><br><span class="line">                   &#125;,</span><br><span class="line">               &#125;,</span><br><span class="line">           &#125;,</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>4.父子组件的访问方式： $children</strong><br><strong>4.1 父组件访问子组件：使用$children或$refs</strong><br>$children: this.$children是一个数组类型，它包含所有子组件对象【缺陷：通过$children访问子组件时，是一个数组类型，访问其中的子组件必须通过索引值】<br>$refs: $refs和ref指令通常是一起使用的，通过ref给某一个子组件绑定一个特定的ID，通过this.$refs.ID访问到该组件<br><code>this.$refs.child 【child为特定的ID，绑定在子组件上】 &lt;my-cpn ref=&quot;child&quot;&gt;&lt;/my-cpn&gt;</code><br><strong>4.2 子组件访问父组件：使用$parent</strong><br><strong>允许通过$parent来访问父组件，但是在真实开发中尽量不要这样做</strong><br><strong>子组件应该尽量避免直接访问父组件的数据，因为这样耦合度太高了</strong><br><strong>如果我们将子组件放在另外一个组件之内，很可能该父组件没有对应的属性，往往会引起问题</strong><br><strong>更不好做的是通过$parent直接修改父组件的状态，那么父组件中的状态将变得飘忽不定，很不利于我的调试和维护</strong></p>
</blockquote>
<blockquote>
<p><strong>5.非父子组件通信</strong><br>1.在Vue1.x的时候，可以通过$dispatch和$broadcast完成<br><strong>$dispatch用于向上级派发事件</strong><br><strong>$broadcast用于向下级广播事件</strong><br>2.在Vue2.x中，有一种方案是通过中央事件总线，也就是一个中介来完成<br>3.Vuex的状态管理</p>
</blockquote>
<blockquote>
<p><strong>6.slot插槽</strong><br><code>使用:在子组件中，使用特殊的元素&lt;slot&gt;就可以为子组件开启一个插槽,该插槽插入什么内容取决于父组件如何使用</code><br><strong>6.1 具名插槽slot【带有name属性】【父组件或实例可以对子组件里的插槽进行修改】</strong><br><code>&lt;slot name=&#39;myslot&#39;&gt;我是插槽01&lt;/slot&gt;     &lt;my-cpn&gt;&lt;span slot=&quot;myslot&quot;&gt;123&lt;/span&gt;&lt;/my-cpn&gt;</code><br><strong>6.2 作用域插槽: 父组件替换插槽的标签，但是内容由子组件来提供</strong><br>使用：<code>通过&lt;template slot-scope=&quot;slotProps&quot;&gt;获取到slotProps属性, 通过slotProps.data获取数据</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">   &lt;my-cpn&gt;</span><br><span class="line">       &lt;template slot-scope=&quot;slotProps&quot;&gt;</span><br><span class="line">           &lt;ul&gt;</span><br><span class="line">               &lt;li v-for=&quot;info in slotProps.data&quot;&gt;&#123;&#123;info&#125;&#125;&lt;/li&gt;</span><br><span class="line">           &lt;/ul&gt;</span><br><span class="line">       &lt;/template&gt;</span><br><span class="line">   &lt;/my-cpn&gt;</span><br><span class="line">&gt;&lt;/div&gt;</span><br><span class="line">&gt;&lt;template id=&quot;myCpn&quot;&gt;</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">       &lt;slot :data=&quot;text&quot;&gt;&lt;/slot&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&gt;&lt;/template&gt;</span><br><span class="line">&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&gt;&lt;script&gt;</span><br><span class="line">   let app = new Vue(&#123;</span><br><span class="line">       el: &#x27;#app&#x27;,</span><br><span class="line">       data:&#123;&#125;,</span><br><span class="line">       components:&#123;</span><br><span class="line">           &#x27;my-cpn&#x27;:&#123;</span><br><span class="line">               template: &#x27;#myCpn&#x27;,</span><br><span class="line">               data()&#123;</span><br><span class="line">                   return&#123;</span><br><span class="line">                       text:[&#x27;Html&#x27;,&#x27;Js&#x27;]</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;,</span><br><span class="line">           &#125;,</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>6.3 编译作用域</strong><br><code>准则：父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译</code><br><strong>my-cpn组件能否渲染出来？</strong><br><img src="/images/%E7%BC%96%E8%AF%91%E4%BD%9C%E7%94%A8%E5%9F%9F.png" alt="编译作用域"></p>
</blockquote>
]]></content>
      <categories>
        <category>Vue基础</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue基础巩固（三）</title>
    <url>/2021/11/12/vue_a_4/</url>
    <content><![CDATA[<blockquote>
<p><strong>1.前端模块化</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;var ModuleA = (function () &#123;</span><br><span class="line">   let obj = &#123;&#125;</span><br><span class="line">   obj.flag = true</span><br><span class="line">   obj.myFunc = function (info) &#123;</span><br><span class="line">       console.log(info)</span><br><span class="line">   &#125;</span><br><span class="line">   return obj</span><br><span class="line">&gt;&#125;)()</span><br><span class="line"></span><br><span class="line">&gt;if(ModuleA.flag)&#123;</span><br><span class="line">   console.log(213)</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;ModuleA.myFunc(&quot;我是一个模块&quot;)</span><br><span class="line">&gt;console.log(ModuleA)</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>2. CommonJS</strong><br><strong>2.1 CommonJS的导出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;module.exports = &#123;</span><br><span class="line">   flag:true,</span><br><span class="line">   test(a,b)&#123;</span><br><span class="line">       return a+ b</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.2 CommonJS的导入</strong><br><code>let &#123; flag ,test&#125; = require(&#39;module.js&#39;)</code></p>
</blockquote>
<blockquote>
<p><strong>3. export【ES6】</strong><br>export使用:export指令用于导出变量,函数,类<br>export default：一个模块中包含某个的功能，不希望给这个功能命名<br><strong>export default在同一个模块中，不允许同时存在多个</strong><br><code>export default  function (a,b) &#123;return a * b&#125; 【info.js文件】</code><br><code>import myFunc from &#39;./info.js&#39; myFunc() 【其他文件中引入】</code></p>
</blockquote>
<blockquote>
<p><strong>4. import【ES6】</strong><br>4.1某个模块中所有的信息都导入<br><strong>通过*导入模块中所有的export变量</strong><br><strong>通常情况下我们需要给*起一个别名，方便后续的使用</strong><br><code>import *as info from &#39;&#39;./info.js</code></p>
</blockquote>
<blockquote>
<p><strong>5. vue-router</strong><br><strong>5.1 vue-router的标签router-link router-view</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// &lt;router-link&gt;: 该标签是一个vue-router中已经内置的组件, 它会被渲染成一个&lt;a&gt;标签</span><br><span class="line">// tag:指定&lt;router-link&gt;之后渲染成什么组件</span><br><span class="line">// replace: replace不会留下history记录, 所以指定replace的情况下, 后退键返回不能返回到上一个页面中</span><br><span class="line">// active-class: 当&lt;router-link&gt;对应的路由匹配成功时, 会自动给当前元素设置一个router-link-active的class, 设置active-class可以修改默认的名称</span><br><span class="line">&lt;router-link to=&#x27;/home&#x27; tag=&#x27;li&#x27;&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-view&gt;: 该标签会根据当前的路径, 动态渲染出不同的组件</span><br><span class="line">// 在路由切换时, 切换的是&lt;router-view&gt;挂载的组件, 其他内容不会发生改变</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 让路径默认跳到到首页:</span><br><span class="line">const routes = [</span><br><span class="line">   &#123;</span><br><span class="line">       path: &#x27;/&#x27;,</span><br><span class="line">       redirect: &#x27;/login&#x27;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">       path: &#x27;/login&#x27;,</span><br><span class="line">       component: () =&gt; import(&#x27;../views/Login&#x27;)</span><br><span class="line">   &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 改变路径的方式: HTML5的history URL的hash</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">   base: process.env.BASE_URL,</span><br><span class="line">   routes,</span><br><span class="line">   mode:&#x27;history&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<p><strong>5.2路由代码跳转</strong><br><code>this.$router.push(“/home”) </code><br><strong>5.3动态路由</strong></p>
<p><strong>5.4路由的懒加载</strong><br>作用:将路由对应的组件打包成一个个的js代码块,只有在这个路由被访问到的时候, 才加载对应的组件<br>方式一: 结合Vue的异步组件和Webpack的代码分析<br><code>const Home = resolve =&gt; &#123; require.ensure([&#39;../components/Home.vue&#39;], () =&gt; &#123; resolve(require(&#39;../components/Home.vue&#39;)) &#125;)&#125;; </code><br>方式二: AMD写法<br><code>const About = resolve =&gt; require([&#39;../components/About.vue&#39;], resolve);</code><br>方式三: 使用ES6写法来组织Vue异步组件和Webpack的代码分割<br><code>const Home = () =&gt; import(&#39;../components/Home.vue&#39;)</code></p>
<p><strong>5.5嵌套路由</strong><br>嵌套路由也可以配置默认的路径<br><code>&#123;path:&#39;&#39;,Redirect:&#39;message&#39;&#125;</code><br><strong>1.在路由映射中配置对应的子路由</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &#x27;/about&#x27;,</span><br><span class="line">  name: &#x27;About&#x27;,</span><br><span class="line">  component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#x27;../views/About.vue&#x27;),</span><br><span class="line">  children:[&#123;</span><br><span class="line">    path:&#x27;/message&#x27;,</span><br><span class="line">    component:() =&gt; import(&#x27;../components/hello.vue&#x27;)</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.在组件内部使用<router-view>标签</strong><br><code>  &lt;router-link to=&quot;/about/message&quot;&gt;跳转hello&lt;/router-link&gt; &lt;router-view&gt;&lt;router-view&gt;</code></p>
<p><strong>5.6传递参数:params和query</strong><br>params的类型:<br>    配置路由格式: /router/:id<br>    传递的方式: 在path后面跟上对应的值<br>    传递后形成的路径: /router/123, /router/abc<br>query的类型:<br>    配置路由格式: /router, 也就是普通配置<br>    传递的方式: 对象中使用query的key作为传递方式<br>    传递后形成的路径: /router?id=123, /router?id=abc<br>使用传递参数：<br><strong>1.router-link标签</strong><br><code>&lt;router-link :to=&quot;&#123;path:&#39;/about/message&#39;,query:&#123;name:&#39;he&#39;,age:18&#125;&#125;&quot;&gt;跳转hello&lt;/router-link&gt;</code><br><strong>2.JavaScript代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$router.push(&#123;</span><br><span class="line">   path:&#x27;/about/message&#x27;,</span><br><span class="line">   query: &#123;name: &#x27;he&#x27;,age:18&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>3.获取参数</strong><br>获取参数通过$route对象获取的<br><strong>4.$route和$router的区别是什么？</strong><br>1.$router为VueRouter实例，想要导航到不同URL，则使用$router.push方法<br>2.$route为当前router跳转对象里面可以获取name、path、query、params等 </p>
<p><strong>5.7导航守卫</strong><br>作用：监听监听路由的进入和离开的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import VueRouter from &#x27;vue-router&#x27;</span><br><span class="line">import Home from &#x27;../views/Home.vue&#x27;</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"> const routes = [</span><br><span class="line"> &#123;</span><br><span class="line">   path: &#x27;/&#x27;,</span><br><span class="line">   name: &#x27;Home&#x27;,</span><br><span class="line">   component: Home,</span><br><span class="line">   meta:&#123;</span><br><span class="line">     title:&#x27;首页&#x27;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">   path: &#x27;/about&#x27;,</span><br><span class="line">   name: &#x27;About&#x27;,</span><br><span class="line">   component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#x27;../views/About.vue&#x27;),</span><br><span class="line">   children:[&#123;</span><br><span class="line">     path:&#x27;message&#x27;,</span><br><span class="line">     component:() =&gt; import(&#x27;../components/hello.vue&#x27;)</span><br><span class="line">   &#125;],</span><br><span class="line">   meta:&#123;</span><br><span class="line">     title:&#x27;关于&#x27;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">   path: &#x27;/register&#x27;,</span><br><span class="line">   name: &#x27;Register&#x27;,</span><br><span class="line">   component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#x27;../views/Register.vue&#x27;),</span><br><span class="line">   meta:&#123;</span><br><span class="line">     title:&#x27;注册&#x27;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">]</span><br><span class="line">//  mode:&#x27;history&#x27; hash</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line"> routes,</span><br><span class="line"> mode:&#x27;hash&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//vue-router提供了beforeEach和afterEach的钩子函数, 它们会在路由即将改变前和改变后触发</span><br><span class="line">//导航钩子的三个参数解析:</span><br><span class="line">//to: 即将要进入的目标的路由对象.</span><br><span class="line">//from: 当前导航即将要离开的路由对象.</span><br><span class="line">//next: 调用该方法后, 才能进入下一个钩子.</span><br><span class="line"></span><br><span class="line">router.beforeEach((to,from,next)=&gt; &#123;</span><br><span class="line"> window.document.title = to.meta.title</span><br><span class="line"> next()</span><br><span class="line">&#125;)</span><br><span class="line">export default router</span><br></pre></td></tr></table></figure>
<p>补充一:如果是后置钩子, 也就是afterEach, 不需要主动调用next()函数.<br>补充二: 上面我们使用的导航守卫, 被称之为全局守卫.<br>路由独享的守卫.<br>组件内的守卫.<br><strong>5.8 keep-alive</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态(不会被重新创建和销毁)，或避免重新渲染</span><br><span class="line">//如果是嵌套路由还需要keep-alive需要包裹App.vue里的router-view</span><br></pre></td></tr></table></figure>
<p>include - 字符串或正则表达，只有匹配的组件会被缓存<br>exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存<br>如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存<br>通过create声明周期函数来验证</p>
</blockquote>
]]></content>
      <categories>
        <category>Vue基础</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3常用Composition Api</title>
    <url>/2021/12/14/vue3_a_2/</url>
    <content><![CDATA[<ol>
<li>去除eslint语法检查操作：文件 =&gt; 首选项 =&gt; 设置 =&gt; 输入eslint，去除第二个勾选</li>
<li>setup 【新的 option, 所有的组合 API 函数都在此使用, 只在初始化时执行一次,函数如果返回对象, 对象中的属性或方法, 模板中可以直接使用】<h1 id="setup和ref的基本使用"><a href="#setup和ref的基本使用" class="headerlink" title="setup和ref的基本使用"></a><strong>setup和ref的基本使用</strong></h1><blockquote>
<p><strong>ref作用: 定义一个数据的响应式</strong></p>
<ul>
<li>语法: const xxx = ref(initValue):</li>
<li>创建一个包含响应式数据的引用(reference)对象</li>
<li>js 中操作数据: xxx.value</li>
<li>模板中操作数据: 不需要.value</li>
<li><em>一般用来定义一个基本类型的响应式数据</em></li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">		&lt;h1&gt;setup和ref的基本使用&lt;/h1&gt;</span><br><span class="line">		&#123;&#123;count&#125;&#125;</span><br><span class="line">		&lt;button @click=&#x27;upDataCount&#x27;&gt;按钮&lt;/button&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	&lt;h3&gt;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&#x27;ts&#x27;&gt;</span><br><span class="line">	import &#123; defineComponent,ref &#125; from &quot;vue&quot;;</span><br><span class="line">	export default defineComponent(&#123;</span><br><span class="line">		name: &quot;App&quot;,</span><br><span class="line">		// 需求：打开页面有一个数组，点击按钮，数组改变</span><br><span class="line">		// setup是组合API的入口函数</span><br><span class="line">		setup() &#123;</span><br><span class="line">			// 变量</span><br><span class="line">			// let count = 0 // 并不是响应式的数据（数据变化，页面跟着变化）</span><br><span class="line">			// ref是一个函数，作用：定义一个响应式数据，对象中有一个value属性</span><br><span class="line">			// html中不需要使用.value属性的</span><br><span class="line">            // 一般用来定义一个基本类型的响应式数据</span><br><span class="line">            // count的对象类型是Ref</span><br><span class="line">			const count = ref(0)</span><br><span class="line">			// 方法</span><br><span class="line">			function upDataCount()&#123;</span><br><span class="line">				// 报错原因：count是一个Ref对象，对象不能进行++操作</span><br><span class="line">				// count++</span><br><span class="line">				count.value++</span><br><span class="line">			&#125;</span><br><span class="line">			// 返回的是一个对象</span><br><span class="line">			return &#123;</span><br><span class="line">				count: count,</span><br><span class="line">				upDataCount</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="reactive-把复杂数据变成响应式数据"><a href="#reactive-把复杂数据变成响应式数据" class="headerlink" title="reactive : 把复杂数据变成响应式数据"></a><strong>reactive : 把复杂数据变成响应式数据</strong></h1></li>
</ol>
<ul>
<li>作用: 定义多个数据的响应式</li>
<li>const proxy = reactive(obj): 接收一个普通对象然后返回该普通对象的响应式代理器对象</li>
<li>响应式转换是“深层的”：会影响对象内部所有嵌套的属性</li>
<li><em>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据都是响应式的</em><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">		&lt;h1&gt;reactive的使用&lt;/h1&gt;</span><br><span class="line">		&lt;h2&gt;姓名：&#123;&#123;user.name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">		&lt;h2&gt;年龄：&#123;&#123;user.age&#125;&#125;&lt;/h2&gt;</span><br><span class="line">		&lt;h2&gt;老婆：&#123;&#123;user.wife&#125;&#125;&lt;/h2&gt;</span><br><span class="line">		&lt;h2&gt;老婆姓名：&#123;&#123;user.wife.name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">		&lt;h2&gt;性别：&#123;&#123;user.gender&#125;&#125;&lt;/h2&gt;</span><br><span class="line">		&lt;button @click=&#x27;upDataCount&#x27;&gt;按钮&lt;/button&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	&lt;h3&gt;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&#x27;ts&#x27;&gt;</span><br><span class="line">	import &#123; defineComponent, reactive &#125; from &quot;vue&quot;;</span><br><span class="line">	export default defineComponent(&#123;</span><br><span class="line">		name: &quot;App&quot;,</span><br><span class="line">		// 需求：显示用户信息，点击按钮，可以更新用户数据</span><br><span class="line">		setup() &#123;</span><br><span class="line">			// 把复杂数据变成响应式数据</span><br><span class="line">			// 接收一个普通对象然后返回该普通对象的响应式代理器对象</span><br><span class="line">			// user的对象类型是Proxy</span><br><span class="line">			const obj: any = &#123;</span><br><span class="line">				name: &#x27;he&#x27;,</span><br><span class="line">				age: 23,</span><br><span class="line">				wife: &#123;</span><br><span class="line">					name: &#x27;zhang&#x27;,</span><br><span class="line">					age: 22</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			const user = reactive &lt; any &gt; (obj)</span><br><span class="line">			// 内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据都是响应式的</span><br><span class="line">			// console.log(user);</span><br><span class="line">			// 方法</span><br><span class="line">			// function upDataCount()&#123;</span><br><span class="line">			// 	user.name = &#x27;zz&#x27;</span><br><span class="line">			// &#125;</span><br><span class="line">			let upDataCount = () =&gt; &#123;</span><br><span class="line">				// user.name = &#x27;xx&#x27;</span><br><span class="line">				// user:代理对象 obj:目标对象</span><br><span class="line">				// 添加一个属性，那种会影响页面的更新</span><br><span class="line">				// obj.gender = &#x27;男&#x27; // 页面不能更新</span><br><span class="line">				// user.gender = &#x27;男&#x27; // 页面更新</span><br><span class="line">				delete user.age // 页面更新</span><br><span class="line">				// 删除一个属性，那种会影响页面的更新</span><br><span class="line">				console.log(user);</span><br><span class="line">			&#125;</span><br><span class="line">			return &#123;</span><br><span class="line">				user: user,</span><br><span class="line">				upDataCount</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="比较-Vue2-与-Vue3-的响应式-重要"><a href="#比较-Vue2-与-Vue3-的响应式-重要" class="headerlink" title="比较 Vue2 与 Vue3 的响应式(重要)"></a><strong>比较 Vue2 与 Vue3 的响应式(重要)</strong></h1><p><strong>Vue2</strong></p>
<ul>
<li>对象: 通过 defineProperty 对对象的已有属性值的读取和修改进行劫持(监视/拦截)</li>
<li>数组: 通过重写数组更新数组一系列更新元素的方法来实现元素修改的劫持</li>
</ul>
<p><strong>Vue2的问题:</strong></p>
<ul>
<li>对象直接新添加的属性或删除已有属性, 界面不会自动更新</li>
<li>直接通过下标替换元素或更新 length, 界面不会自动更新 arr[1] = {}</li>
</ul>
<p><strong>Vue3</strong></p>
<ul>
<li>通过 Proxy(代理): 拦截对 data 任意属性的任意(13 种)操作, 包括属性值的读写, 属性的添加, 属性的删除等</li>
<li>通过 Reflect(反射): 动态对被代理对象的相应属性进行特定的操作<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">		&lt;h1&gt;reactive的使用&lt;/h1&gt;</span><br><span class="line">		&lt;h2&gt;&#123;&#123;user.name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">		&lt;h2&gt;&#123;&#123;user.wife&#125;&#125;&lt;/h2&gt;</span><br><span class="line">		&lt;h2&gt;&#123;&#123;user.wife.name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">		&lt;button @click=&#x27;upDataCount&#x27;&gt;按钮&lt;/button&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	&lt;h3&gt;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">	import &#123; defineComponent, reactive &#125; from &quot;vue&quot;;</span><br><span class="line">	export default defineComponent(&#123;</span><br><span class="line">		name: &quot;App&quot;,</span><br><span class="line">		setup() &#123;</span><br><span class="line">			const user = &#123;</span><br><span class="line">				name: &#x27;he&#x27;,</span><br><span class="line">				age: 23,</span><br><span class="line">				wife: &#123;</span><br><span class="line">					name: &#x27;zhang&#x27;,</span><br><span class="line">					age: 22</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			// target: 要使用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）</span><br><span class="line">			// handler: 一个通常以函数作为属性的对象，各属性中的函数分别定义了执行各种操作时代理proxy的行为。</span><br><span class="line">			const proxy = new Proxy(user, &#123;</span><br><span class="line">				// target:目标对象  property:属性名 receiver: Proxy 或者继承Proxy的对象</span><br><span class="line">				// 用于拦截对象的读取属性操作</span><br><span class="line">				get(target, prop) &#123;</span><br><span class="line">					console.log(&#x27;get调用&#x27;);</span><br><span class="line">					// return Reflect.get(user, &quot;name&quot;); // he</span><br><span class="line">					return Reflect.get(target, prop)</span><br><span class="line">				&#125;,</span><br><span class="line">				// 设置属性值操作的器皿</span><br><span class="line">				set(target, prop, val) &#123;</span><br><span class="line">					console.log(&#x27;set调用&#x27;);</span><br><span class="line">					return Reflect.set(target, prop, val)</span><br><span class="line">				&#125;,</span><br><span class="line">				// 拦截对对象的delete操作</span><br><span class="line">				// 拦截删除属性</span><br><span class="line">				deleteProperty(target, prop) &#123;</span><br><span class="line">					console.log(&#x27;deleteProperty调用&#x27;);</span><br><span class="line">					return Reflect.deleteProperty(target, prop)</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;)</span><br><span class="line">			// get调用</span><br><span class="line">			// console.log(proxy.name);</span><br><span class="line"></span><br><span class="line">			// set调用</span><br><span class="line">			// proxy.name = &#x27;lisi&#x27;</span><br><span class="line">			// proxy.gender = &#x27;男&#x27;</span><br><span class="line"></span><br><span class="line">			// deleteProperty调用</span><br><span class="line">			// delete proxy.age</span><br><span class="line">			</span><br><span class="line">			// get调用</span><br><span class="line">			// proxy.wife.name = &#x27;wanwu&#x27;</span><br><span class="line">			delete proxy.wife.name</span><br><span class="line"></span><br><span class="line">			console.log(user);</span><br><span class="line">			console.log(proxy);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			// let upDataCount = () =&gt; &#123;</span><br><span class="line">			// 	console.log(user);</span><br><span class="line">			// &#125;</span><br><span class="line">			return &#123;</span><br><span class="line">				user: user,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="setup-细节"><a href="#setup-细节" class="headerlink" title="setup 细节"></a><strong>setup 细节</strong></h1><p><strong>1.setup 执行的时机</strong></p>
<blockquote>
<ul>
<li>在 beforeCreate 之前执行(一次), 此时组件对象还没有创建</li>
<li>this 是 undefined, 不能通过 this 来访问 data/computed/methods / props</li>
<li>其实所有的 composition API 相关回调函数中也都不可以</li>
</ul>
</blockquote>
<p><strong>2.setup 返回值</strong></p>
<blockquote>
<ul>
<li>返回一个对象，可以直接使用对象中的属性或方法</li>
<li>返回对象中的属性会与 data 函数返回对象的属性合并成为组件对象的属性</li>
<li>返回对象中的方法会与 methods 中的方法合并成功组件对象的方法</li>
<li>setup 不能是一个 async 函数: 因为返回值不再是 return 的对象, 而是 promise, 模板看不到 return 对象中的属性数据</li>
</ul>
</blockquote>
<p><strong>3.setup 参数</strong></p>
<blockquote>
<ul>
<li>setup(props, context) / setup(props, {attrs, slots, emit})</li>
<li>props: 包含 props 配置声明且传入了的所有属性的对象</li>
<li>attrs: 包含没有在 props 配置中声明的属性的对象, 相当于 this.$attrs</li>
<li>slots: 包含所有传入的插槽内容的对象, 相当于 this.$slots</li>
<li>emit: 用来分发自定义事件的函数, 相当于 this.$emit<br>Child.vue</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;Child子组件&lt;/h2&gt;</span><br><span class="line">  &lt;h3&gt;msg:&#123;&#123; msg &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;!-- &lt;h3&gt;num:&#123;&#123; num &#125;&#125;&lt;/h3&gt; --&gt;</span><br><span class="line">  &lt;button @click=&quot;emitHandle&quot;&gt;分发事件&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, ref &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &quot;Child&quot;,</span><br><span class="line">  props: [&quot;msg&quot;],</span><br><span class="line">  // setup细节问题：</span><br><span class="line">  // 1.setup 执行的时机</span><br><span class="line">  // 在 beforeCreate 之前执行(一次), 此时组件对象还没有创建</span><br><span class="line">  // setup在执行的时候，当前组件还没有创建，实例对象this为undefined</span><br><span class="line">  // 不能通过 this 来访问 data/computed/methods / props</span><br><span class="line">  // 其实所有的 composition API 相关回调函数中也都不可以</span><br><span class="line"></span><br><span class="line">  // 2.setup 的 返回值</span><br><span class="line">  // 返回对象中的属性会与 data 函数返回对象的属性合并成为组件对象的属性</span><br><span class="line">  // 返回对象中的方法会与 methods 中的方法合并成功组件对象的方法</span><br><span class="line">  // 如果有重名, setup 优先</span><br><span class="line">  // setup 不能是一个 async 函数: 因为返回值不再是 return 的对象, 而是 promise, 模板看不到 return 对象中的属性数据</span><br><span class="line"></span><br><span class="line">  // 3.setup 的参数</span><br><span class="line">  // props:是一个对象，里面包含父组件向子组件传递的数据,子组件使用props接收到的所有属性</span><br><span class="line">  // context:是一个对象,里面有attrs对象（获取当前组件标签上的属性，在props中没有声明）,emit方法（分发事件），slots对象（插槽）</span><br><span class="line">  // attrs:包含没有在 props 配置中声明的属性的对象, 相当于 this.$attrs</span><br><span class="line">  // emit：用来分发自定义事件的函数, 相当于 this.$emit</span><br><span class="line"></span><br><span class="line">  // setup(props, context) &#123;</span><br><span class="line">  setup(props, &#123; attrs, emit, slots &#125;) &#123;</span><br><span class="line">    console.log(props.msg);</span><br><span class="line">    console.log(attrs.msg1);</span><br><span class="line">    const num = ref(7);</span><br><span class="line">    let showMsg1 = () =&gt; &#123;</span><br><span class="line">      console.log(123);</span><br><span class="line">    &#125;;</span><br><span class="line">    // 按钮的点击事件</span><br><span class="line">    function emitHandle() &#123;</span><br><span class="line">      emit(&quot;xxx&quot;, &quot;--&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      num,</span><br><span class="line">      showMsg1,</span><br><span class="line">      emitHandle,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  // beforeCreate() &#123;</span><br><span class="line">  //   console.log(&quot;beforeCreate&quot;);</span><br><span class="line">  // &#125;,</span><br><span class="line">  // data() &#123;</span><br><span class="line">  //   return &#123;</span><br><span class="line">  //     num: 10,</span><br><span class="line">  //   &#125;;</span><br><span class="line">  // &#125;,</span><br><span class="line">  // methods: &#123;</span><br><span class="line">  //   shwoMsg2() &#123;</span><br><span class="line">  //     console.log(123123);</span><br><span class="line">  //   &#125;,</span><br><span class="line">  // &#125;,</span><br><span class="line">  // mounted() &#123;</span><br><span class="line">  //   console.log(this);</span><br><span class="line">  // &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>App.vue</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;App父组件&lt;/h2&gt;</span><br><span class="line">  &lt;h3&gt;msg:&#123;&#123; msg &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;button @click=&quot;msg += &#x27;===&#x27;&quot;&gt;更新数据&lt;/button&gt;</span><br><span class="line">  &lt;hr /&gt;</span><br><span class="line">  &lt;Child :msg=&quot;msg&quot; :msg1=&quot;msg1&quot; @xxx=&quot;handle&quot;/&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, ref &#125; from &quot;vue&quot;;</span><br><span class="line">import Child from &quot;./components/Child.vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line">  // 注册组件</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child,</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props, &#123; attrs, emit, slots &#125;) &#123;</span><br><span class="line">    // 定义一个ref类型的数据</span><br><span class="line">    const msg = ref(&quot;what are you nong sai lei ?&quot;);</span><br><span class="line">    const msg1 = ref(&quot;123456&quot;);</span><br><span class="line">    function handle (data:string)&#123;</span><br><span class="line">      msg.value += data</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123; msg,msg1,handle &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="reactive-与-ref-细节"><a href="#reactive-与-ref-细节" class="headerlink" title="reactive 与 ref-细节"></a><strong>reactive 与 ref-细节</strong></h1><ul>
<li>是 Vue3 的 composition API 中 2 个最重要的响应式 API</li>
<li>ref 用来处理基本类型数据, reactive 用来处理对象(递归深度响应式)</li>
<li>如果用 ref 对象/数组, 内部会自动将对象/数组转换为 reactive 的代理对象</li>
<li>ref 内部: 通过给 value 属性添加 getter/setter 来实现对数据的劫持</li>
<li>reactive 内部: 通过使用 Proxy 来实现对对象内部所有数据的劫持, 并通过 Reflect 操作对象内部数据</li>
<li>ref 的数据操作: 在 js 中要.value, 在模板中不需要(内部解析模板时会自动添加.value)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;reactive 与 ref-细节&lt;/h2&gt;</span><br><span class="line">  &lt;h3&gt;m1:&#123;&#123; m1 &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;h3&gt;m2:&#123;&#123; m2 &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;h3&gt;m3:&#123;&#123; m3 &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;button @click=&quot;handleUpdata&quot;&gt;更新数据&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, reactive, ref &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &quot;&quot;,</span><br><span class="line">  // 是 Vue3 的 composition API 中 2 个最重要的响应式 API</span><br><span class="line">  // ref中如果放入的是一个对象，会经过 reactive的处理，形成一个Proxy类型的对象</span><br><span class="line">  setup(props, &#123; attrs, emit, slots &#125;) &#123;</span><br><span class="line">    let m1 = ref(0);</span><br><span class="line">    let m2 = reactive(&#123; name: &quot;bai&quot;, age: 23, wife: [&quot;xiao&quot;, &quot;li&quot;, &quot;zhao&quot;] &#125;);</span><br><span class="line">    let m3 = ref(&#123;</span><br><span class="line">      name: &quot;he&quot;,</span><br><span class="line">      age: 23,</span><br><span class="line">      wife: [&quot;xiao&quot;, &quot;li&quot;, &quot;zhao&quot;],</span><br><span class="line">    &#125;);</span><br><span class="line">    function handleUpdata() &#123;</span><br><span class="line">      // m1.value = 13</span><br><span class="line">      // m2.age = 12</span><br><span class="line">      // m2.wife[0] = &#x27;liu&#x27;</span><br><span class="line">      m3.value.age = 12;</span><br><span class="line">      m3.value.wife[0] = &quot;liu&quot;;  </span><br><span class="line">      console.log(m3.value.wife);</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      m1,</span><br><span class="line">      m2,</span><br><span class="line">      m3,</span><br><span class="line">      handleUpdata,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="计算属性与监视"><a href="#计算属性与监视" class="headerlink" title="计算属性与监视"></a><strong>计算属性与监视</strong></h1></li>
<li><em>重点：计算属性的属性的类型是ref类型，属性.value取值</em>*<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;计算属性与监视&lt;/h2&gt;</span><br><span class="line">  &lt;fieldset&gt;</span><br><span class="line">    &lt;legend&gt;姓名操作&lt;/legend&gt;</span><br><span class="line">    姓：&lt;input</span><br><span class="line">      type=&quot;text&quot;</span><br><span class="line">      placeholder=&quot;请输入姓&quot;</span><br><span class="line">      v-model=&quot;user.Firstname&quot;</span><br><span class="line">    /&gt;&lt;br /&gt;</span><br><span class="line">    名：&lt;input</span><br><span class="line">      type=&quot;text&quot;</span><br><span class="line">      placeholder=&quot;请输入名&quot;</span><br><span class="line">      v-model=&quot;user.Lastname&quot;</span><br><span class="line">    /&gt;&lt;br /&gt;</span><br><span class="line">  &lt;/fieldset&gt;</span><br><span class="line">  &lt;fieldset&gt;</span><br><span class="line">    &lt;legend&gt;计算属性与监视的演示&lt;/legend&gt;</span><br><span class="line">    姓名：&lt;input type=&quot;text&quot; placeholder=&quot;显示姓名&quot; v-model=&quot;Fullname1&quot; /&gt;&lt;br /&gt;</span><br><span class="line">    姓名：&lt;input type=&quot;text&quot; placeholder=&quot;显示姓名&quot; v-model=&quot;Fullname2&quot; /&gt;&lt;br /&gt;</span><br><span class="line">    姓名：&lt;input type=&quot;text&quot; placeholder=&quot;显示姓名&quot; v-model=&quot;Fullname3&quot; /&gt;&lt;br /&gt;</span><br><span class="line">  &lt;/fieldset&gt;</span><br><span class="line">  &lt;button @click=&quot;handleUpdata&quot;&gt;更新数据&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123;</span><br><span class="line">  computed,</span><br><span class="line">  defineComponent,</span><br><span class="line">  reactive,</span><br><span class="line">  ref,</span><br><span class="line">  watch,</span><br><span class="line">  watchEffect,</span><br><span class="line">&#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &quot;&quot;,</span><br><span class="line">  setup(props, &#123; attrs, emit, slots &#125;) &#123;</span><br><span class="line">    let name = ref(&quot;he&quot;);</span><br><span class="line">    let user = reactive(&#123;</span><br><span class="line">      Firstname: &quot;西门&quot;,</span><br><span class="line">      Lastname: &quot;吹雪&quot;,</span><br><span class="line">    &#125;);</span><br><span class="line">    function handleUpdata() &#123;</span><br><span class="line">      console.log(123);</span><br><span class="line">    &#125;</span><br><span class="line">    //通过计算属性，实现第一个姓名显示</span><br><span class="line">    // vue3的计算属性，只传入一个回调函数，表示get,需要使用get和set,传入一个对象</span><br><span class="line">    // 返回的是一个ref的对象</span><br><span class="line">    // 第一个姓名</span><br><span class="line">    const Fullname1 = computed(() =&gt; &#123;</span><br><span class="line">      return user.Firstname + user.Lastname;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 第二个姓名</span><br><span class="line">    const Fullname2 = computed(&#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        return user.Firstname + &quot;_&quot; + user.Lastname;</span><br><span class="line">      &#125;,</span><br><span class="line">      set(val: string) &#123;</span><br><span class="line">        let name = val.split(&quot;_&quot;);</span><br><span class="line">        user.Firstname = name[0];</span><br><span class="line">        user.Lastname = name[1];</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    // 第三的姓名</span><br><span class="line">    const Fullname3 = ref(&quot;&quot;);</span><br><span class="line">    // 监视 ---监视指定的数据</span><br><span class="line">    // immediate:true 默认执行一次 deep:true 深度监视</span><br><span class="line">    watch(</span><br><span class="line">      user,</span><br><span class="line">      (&#123; Firstname, Lastname &#125;) =&gt; &#123;</span><br><span class="line">        Fullname3.value = Firstname + &quot;_&quot; + Lastname;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; immediate: true, deep: true &#125;</span><br><span class="line">    );</span><br><span class="line">    // 不需要配置 immediate，就会执行一次</span><br><span class="line">    // watchEffect(()=&gt;&#123;</span><br><span class="line">    // 	Fullname3.value = user.Firstname + &quot;_&quot; + user.Lastname;</span><br><span class="line">    // &#125;)</span><br><span class="line">    watchEffect(() =&gt; &#123;</span><br><span class="line">      const names = Fullname3.value.split(&quot;_&quot;);</span><br><span class="line">      user.Firstname = names[0];</span><br><span class="line">      user.Lastname = names[1];</span><br><span class="line">    &#125;);</span><br><span class="line">    // watch可以监视多个数据</span><br><span class="line">    // watch([user.Firstname,user.Lastname],()=&gt;&#123;</span><br><span class="line">    // 	// 这里代码没有执行，Fullname3是响应式的数据，user.Firstname和user.Lastname不是</span><br><span class="line">    // 	console.log(&#x27;非响应式&#x27;);</span><br><span class="line">    // &#125;)</span><br><span class="line">		// 如果watch监视的是响应式数据的属性时，使用回调的方式才可以监视他</span><br><span class="line">    watch([() =&gt; user.Firstname, () =&gt; user.Lastname, Fullname3], () =&gt; &#123;</span><br><span class="line">      // 这里代码没有执行，Fullname3是响应式的数据，user.Firstname和user.Lastname不是</span><br><span class="line">      console.log(&quot;======&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      name,</span><br><span class="line">      user,</span><br><span class="line">      handleUpdata,</span><br><span class="line">      Fullname1,</span><br><span class="line">      Fullname2,</span><br><span class="line">      Fullname3,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="vue3和vue2生命周期对比"><a href="#vue3和vue2生命周期对比" class="headerlink" title="vue3和vue2生命周期对比"></a><strong>vue3和vue2生命周期对比</strong></h1><blockquote>
<p>beforeCreate -&gt; 使用 setup()<br>created -&gt; 使用 setup()<br>beforeMount -&gt; onBeforeMount<br>mounted -&gt; onMounted<br>beforeUpdate -&gt; onBeforeUpdate<br>updated -&gt; onUpdated<br>beforeDestroy -&gt; onBeforeUnmount<br>destroyed -&gt; onUnmounted<br>errorCaptured -&gt; onErrorCaptured</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>app.vue</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;App父组件&lt;/h2&gt;</span><br><span class="line">	&lt;hr/&gt;</span><br><span class="line">	&lt;button @click=&quot;isShow=!isShow&quot;&gt;切换显示&lt;/button&gt;</span><br><span class="line">  &lt;Child v-if=&quot;isShow&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;@vue/reactivity&#x27;;</span><br><span class="line">import Child from &quot;./components/Child.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child,</span><br><span class="line">  &#125;,</span><br><span class="line">	setup()&#123;</span><br><span class="line">		let isShow = ref(false)</span><br><span class="line">		return&#123;</span><br><span class="line">			isShow</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>child.vue</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;about&quot;&gt;</span><br><span class="line">    &lt;h2&gt;子组件Child&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;msg: &#123;&#123; msg &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;hr /&gt;</span><br><span class="line">    &lt;button @click=&quot;update&quot;&gt;更新&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123;</span><br><span class="line">  ref,</span><br><span class="line">  onMounted,</span><br><span class="line">  onUpdated,</span><br><span class="line">  onUnmounted,</span><br><span class="line">  onBeforeMount,</span><br><span class="line">  onBeforeUpdate,</span><br><span class="line">  onBeforeUnmount,</span><br><span class="line">&#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // vue2中的生命周期钩子</span><br><span class="line">  beforeCreate() &#123;</span><br><span class="line">    console.log(&quot;beforeCreate()&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(&quot;created&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeMount() &#123;</span><br><span class="line">    console.log(&quot;beforeMount&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(&quot;mounted&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeUpdate() &#123;</span><br><span class="line">    console.log(&quot;beforeUpdate&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  updated() &#123;</span><br><span class="line">    console.log(&quot;updated&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  // vue3中已经改了</span><br><span class="line">  // beforeDestroy()&#123;&#125;,</span><br><span class="line">  // destroyed()&#123;&#125;</span><br><span class="line">  beforeUnmount() &#123;</span><br><span class="line">    console.log(&quot;beforeUnmount&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  unmounted() &#123;</span><br><span class="line">    console.log(&quot;unmounted&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const msg = ref(&quot;abc&quot;);</span><br><span class="line">    console.log(msg,&#x27;vue3--setup&#x27;);</span><br><span class="line">    </span><br><span class="line">    const update = () =&gt; &#123;</span><br><span class="line">      msg.value += &quot;--&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    onBeforeMount(() =&gt; &#123;</span><br><span class="line">      console.log(&quot;vue3 --onBeforeMount&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    onMounted(() =&gt; &#123;</span><br><span class="line">      console.log(&quot;vue3 --onMounted&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    onBeforeUpdate(() =&gt; &#123;</span><br><span class="line">      console.log(&quot;vue3 --onBeforeUpdate&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    onUpdated(() =&gt; &#123;</span><br><span class="line">      console.log(&quot;vue3 --onUpdated&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    onBeforeUnmount(() =&gt; &#123;</span><br><span class="line">      console.log(&quot;vue3 --onBeforeUnmount&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    onUnmounted(() =&gt; &#123;</span><br><span class="line">      console.log(&quot;vue3 --onUnmounted&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      msg,</span><br><span class="line">      update,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="自定义hook函数"><a href="#自定义hook函数" class="headerlink" title=". 自定义hook函数"></a>. <strong>自定义hook函数</strong></h1><ul>
<li>作用:使用 Vue3 的组合 API 封装的可复用的功能函数</li>
<li>创建文件开头带use</li>
<li>自定义 hook 的作用类似于 vue2 中的 mixin 技术</li>
<li>自定义 Hook 的优势: 很清楚复用功能代码的来源, 更清楚易懂<blockquote>
<p>App.vue</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;自定义hook函数&lt;/h2&gt;</span><br><span class="line">  &lt;h2&gt;x:&#123;&#123; x &#125;&#125;,y:&#123;&#123; y &#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;h3 v-if=&quot;loading&quot;&gt;正在加载中&lt;/h3&gt;</span><br><span class="line">  &lt;h3 v-else-if=&quot;errorMsg&quot;&gt;错误信息：&#123;&#123; errorMsg &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;ul v-else&gt;</span><br><span class="line">    &lt;li&gt;id:&#123;&#123; data.id &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;title:&#123;&#123; data.address &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;price:&#123;&#123; data.distance &#125;&#125;&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">  &lt;ul v-for=&quot;item in data&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">    &lt;li&gt;id:&#123;&#123; item.id &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;title:&#123;&#123; item.title &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;price:&#123;&#123; item.price &#125;&#125;&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&#x27;ts&#x27;&gt;</span><br><span class="line">import &#123;</span><br><span class="line">  defineComponent,</span><br><span class="line">  onBeforeMount,</span><br><span class="line">  onMounted,</span><br><span class="line">  reactive,</span><br><span class="line">  ref,</span><br><span class="line">  watch,</span><br><span class="line">&#125; from &quot;vue&quot;;</span><br><span class="line">import usehook from &quot;./hook/usehook&quot;;</span><br><span class="line">import usereq from &quot;./hook/usereq&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &quot;&quot;,</span><br><span class="line">  // 需求：用户在页面点击，把点击的横纵坐标收集展示</span><br><span class="line">  setup() &#123;</span><br><span class="line">    // let x = ref(&quot;-1&quot;);</span><br><span class="line">    // let y = ref(&quot;-1&quot;);</span><br><span class="line">    // // 点击事件的回调函数</span><br><span class="line">    // const handleClick = (event: any) =&gt; &#123;</span><br><span class="line">    //   x.value = event.pageX;</span><br><span class="line">    //   y.value = event.pageY;</span><br><span class="line">    // &#125;;</span><br><span class="line">    // // 页面加载完毕，进行点击操作</span><br><span class="line">    // onMounted(() =&gt; &#123;</span><br><span class="line">    //   window.addEventListener(&quot;click&quot;, handleClick);</span><br><span class="line">    // &#125;);</span><br><span class="line">    // onBeforeMount(() =&gt; &#123;</span><br><span class="line">    //   window.removeEventListener(&quot;click&quot;, handleClick);</span><br><span class="line">    // &#125;);</span><br><span class="line">    const &#123; x, y &#125; = usehook();</span><br><span class="line">    // 定义接口，约束对象的类型</span><br><span class="line">    interface AddressData &#123;</span><br><span class="line">      id: number;</span><br><span class="line">      address: string;</span><br><span class="line">      distance: string;</span><br><span class="line">    &#125;</span><br><span class="line">    interface Price &#123;</span><br><span class="line">      id: number;</span><br><span class="line">      title: string;</span><br><span class="line">      price: number;</span><br><span class="line">    &#125;</span><br><span class="line">    // 发送请求</span><br><span class="line">    // const &#123; loading, data, errorMsg &#125; = usereq&lt;AddressData&gt;(&quot;/data/address.json&quot;); //获取对象数据</span><br><span class="line">    const &#123; loading, data, errorMsg &#125; = usereq&lt;Price[]&gt;(&quot;/data/data.json&quot;); //获取对象数据</span><br><span class="line"></span><br><span class="line">    watch(data, () =&gt; &#123;</span><br><span class="line">      if (data.value) &#123;</span><br><span class="line">        console.log(data.value.length);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return &#123; x, y, loading, data, errorMsg &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>hook/usereq.ts</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 引入axios</span><br><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">// 发送ajax</span><br><span class="line">export default function&lt;T&gt; (url: string) &#123;</span><br><span class="line">    // 加载的状态</span><br><span class="line">    const loading = ref(true)</span><br><span class="line">    // 请求成功的数组</span><br><span class="line">    const data = ref&lt;T|null&gt;(null)</span><br><span class="line">    // 错误信息</span><br><span class="line">    const errorMsg = ref(&#x27;&#x27;)</span><br><span class="line">    axios.get(url).then(res =&gt; &#123;</span><br><span class="line">        // 改变加载状态</span><br><span class="line">        loading.value = false</span><br><span class="line">        data.value = res.data</span><br><span class="line">        console.log(111111,data.value);</span><br><span class="line">        </span><br><span class="line">    &#125;).catch(err =&gt; &#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">        </span><br><span class="line">        // 改变加载状态</span><br><span class="line">        loading.value = false</span><br><span class="line">        errorMsg.value = err.message || &#x27;error&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">    return &#123;</span><br><span class="line">        loading,</span><br><span class="line">        data,</span><br><span class="line">        errorMsg</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>hook/usehook.ts</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; onBeforeMount, onMounted, ref &#125; from &quot;vue&quot;;</span><br><span class="line">export default function () &#123;</span><br><span class="line">    const x = ref(-1);</span><br><span class="line">    const y = ref(-1);</span><br><span class="line">    // 点击事件的回调函数</span><br><span class="line">    const handleClick = (event: MouseEvent) =&gt; &#123;</span><br><span class="line">        x.value = event.pageX;</span><br><span class="line">        y.value = event.pageY;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 页面加载完毕，进行点击操作</span><br><span class="line">    onMounted(() =&gt; &#123;</span><br><span class="line">        window.addEventListener(&quot;click&quot;, handleClick);</span><br><span class="line">    &#125;);</span><br><span class="line">    onBeforeMount(() =&gt; &#123;</span><br><span class="line">        window.removeEventListener(&quot;click&quot;, handleClick);</span><br><span class="line">    &#125;);</span><br><span class="line">    return &#123;</span><br><span class="line">        x, y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>public/data/data.json</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    &quot;id&quot;:2,</span><br><span class="line">    &quot;title&quot;:&quot;oppe&quot;,</span><br><span class="line">    &quot;price&quot;:2999</span><br><span class="line"></span><br><span class="line">&#125;,&#123;</span><br><span class="line">    &quot;id&quot;:78,</span><br><span class="line">    &quot;title&quot;:&quot;vivo&quot;,</span><br><span class="line">    &quot;price&quot;:1599</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>public/data/address.json</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;:1,</span><br><span class="line">    &quot;address&quot;:&quot;四川省成都市二仙桥&quot;,</span><br><span class="line">    &quot;distance&quot;:&quot;200m&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="toRefs的使用"><a href="#toRefs的使用" class="headerlink" title="toRefs的使用"></a><strong>toRefs的使用</strong></h1></li>
<li><em>问题: reactive 对象取出的所有属性值都是非响应式的</em>*</li>
<li><em>解决: 利用 toRefs 可以将一个响应式 reactive 对象的所有原始属性转换为响应式的 ref 属性</em>*</li>
<li><em>应用: 当从合成函数返回响应式对象时，toRefs 非常有用，这样消费组件就可以在不丢失响应式的情况下对返回的对象进行分解使用</em>*<br><code>const &#123; name, age &#125; = toRefs(state);</code></li>
<li>toRefs 可以把reactive包裹的数据变成普通对象包裹的ref对象</li>
<li>toRefs把一个响应式对象转换成普通对象，该普通对象的每个 property 都是一个 ref<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;toRefs的使用&lt;/h2&gt;</span><br><span class="line">  &lt;!-- &lt;h3&gt;name:&#123;&#123; state.name &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;h3&gt;age:&#123;&#123; state.age &#125;&#125;&lt;/h3&gt; --&gt;</span><br><span class="line">  &lt;h3&gt;name:&#123;&#123; name &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;h3&gt;age:&#123;&#123; age &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;hr /&gt;</span><br><span class="line">  &lt;h3&gt;name2:&#123;&#123; name2 &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;h3&gt;age2:&#123;&#123; age2 &#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">// 应用场景</span><br><span class="line">function handleinfo() &#123;</span><br><span class="line">  const state = reactive(&#123;</span><br><span class="line">    name2: &quot;her&quot;,</span><br><span class="line">    age2: 233,</span><br><span class="line">  &#125;);</span><br><span class="line">  return &#123;</span><br><span class="line">    ...toRefs(state),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import &#123; defineComponent, reactive, toRefs &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &quot;&quot;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const state = reactive(&#123;</span><br><span class="line">      name: &quot;he&quot;,</span><br><span class="line">      age: 23,</span><br><span class="line">    &#125;);</span><br><span class="line">    const &#123; name2, age2 &#125; = handleinfo();</span><br><span class="line"></span><br><span class="line">    // const state2 = toRefs(state)</span><br><span class="line">    const &#123; name, age &#125; = toRefs(state);</span><br><span class="line">    // toRefs 可以把reactive包裹的数据变成普通对象包裹的ref对象</span><br><span class="line">    //  toRefs把一个响应式对象转换成普通对象，该普通对象的每个 property 都是一个 ref</span><br><span class="line">    // 定时器 更新数据 (如果数据变化了，页面也会跟着变化,证明是响应式的数据)</span><br><span class="line">    setInterval(() =&gt; &#123;</span><br><span class="line">      // state.name += &quot;===&quot;;</span><br><span class="line">      // state2.name.value += &quot;===&quot;;</span><br><span class="line">      // name.value += &quot;===&quot;;</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">    return &#123;</span><br><span class="line">      state,</span><br><span class="line">      // ...state, // 不是响应式的数据</span><br><span class="line">      // ...state2 // toRefs返回来的数据</span><br><span class="line">      name,</span><br><span class="line">      age,</span><br><span class="line">      name2,</span><br><span class="line">      age2,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="ref-获取元素"><a href="#ref-获取元素" class="headerlink" title="ref 获取元素"></a><strong>ref 获取元素</strong></h1></li>
<li>利用 ref 函数获取组件中的标签元素<blockquote>
<p><strong>功能需求: 让输入框自动获取焦点</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;ref获取元素&lt;/h2&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; ref=&quot;inputRef&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; defineComponent, onMounted, ref &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &quot;&quot;,</span><br><span class="line">  // 功能需求: 让输入框自动获取焦点</span><br><span class="line">  setup(props, &#123; attrs, emit, slots &#125;) &#123;</span><br><span class="line">    // 默认是空的，页面加载完毕，说明组件已经存在，获取文本框元素</span><br><span class="line">    const inputRef = ref&lt;HTMLElement|null&gt;(null);</span><br><span class="line">    onMounted(()=&gt;&#123;</span><br><span class="line">      inputRef.value &amp;&amp; inputRef.value.focus() //自动获取焦点 </span><br><span class="line">    &#125;)</span><br><span class="line">    return &#123;</span><br><span class="line">      inputRef,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Vue3基础</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>React知识点————入门【第一章】</title>
    <url>/2021/12/30/01.React/</url>
    <content><![CDATA[<h1 id="React：是一个将数据渲染为HTML视图的开源JS库"><a href="#React：是一个将数据渲染为HTML视图的开源JS库" class="headerlink" title="React：是一个将数据渲染为HTML视图的开源JS库"></a>React：是一个将数据渲染为HTML视图的开源JS库</h1><h1 id="js痛点：原生js操作DOM繁琐，效率低【DOM-API-操作-UI】-js操作DOM-浏览器进行大量的重绘重排-js没有组件化的方案，代码复用率低"><a href="#js痛点：原生js操作DOM繁琐，效率低【DOM-API-操作-UI】-js操作DOM-浏览器进行大量的重绘重排-js没有组件化的方案，代码复用率低" class="headerlink" title="js痛点：原生js操作DOM繁琐，效率低【DOM-API 操作 UI】; js操作DOM,浏览器进行大量的重绘重排 ; js没有组件化的方案，代码复用率低"></a>js痛点：原生js操作DOM繁琐，效率低【DOM-API 操作 UI】; js操作DOM,浏览器进行大量的重绘重排 ; js没有组件化的方案，代码复用率低</h1><h1 id="React的特点"><a href="#React的特点" class="headerlink" title="React的特点"></a>React的特点</h1><ul>
<li>采用组件化模式，声明式编程，提高开发效率和组件复用率</li>
<li>React Native 可以进行移动端开发【安卓，ios】</li>
<li>使用虚拟DOM + Diffing算法，减少与真实DOM的交互</li>
</ul>
<h1 id="认识React-js"><a href="#认识React-js" class="headerlink" title="认识React.js"></a>认识React.js</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;!-- react核心库 --&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- 用于支持react操作dom --&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- babel用于将jsx转成js【babel也有ES6转ES5的功能】 --&gt;</span><br><span class="line">    &lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- type=&quot;text/babel&quot; 表示写的内容为jsx --&gt;</span><br><span class="line">    &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">        // 1.创建虚拟DOM  【不用加引号，他是虚拟DOM】</span><br><span class="line">        const VDOM = &lt;h2&gt;123456&lt;/h2&gt;</span><br><span class="line">        // 2.渲染虚拟DOM到页面</span><br><span class="line">        // ReactDOM.render(虚拟DOM,容器)</span><br><span class="line">        ReactDOM.render(VDOM, document.getElementById(&quot;app&quot;))</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h1 id="使用js和jsx创建虚拟DOM"><a href="#使用js和jsx创建虚拟DOM" class="headerlink" title="使用js和jsx创建虚拟DOM"></a>使用js和jsx创建虚拟DOM</h1><ul>
<li>jsx:可以更加简洁编写虚拟DOM<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;使用js和jsx创建虚拟DOM&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;text&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- jsx创建虚拟DOM --&gt;</span><br><span class="line">    &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">        const VDOM = (</span><br><span class="line">            &lt;h1 id=&#x27;title&#x27;&gt;</span><br><span class="line">                &lt;span&gt;jsx:123456&lt;/span&gt;</span><br><span class="line">            &lt;/h1&gt;</span><br><span class="line">        )</span><br><span class="line">        ReactDOM.render(VDOM, document.getElementById(&quot;app&quot;))</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- js创建虚拟DOM --&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        // document.createElement(标签名，标签属性，标签内容)</span><br><span class="line">        const VDOM1 = React.createElement(&#x27;h1&#x27;, &#123;&#125;, React.createElement(&#x27;span&#x27;, &#123;&#125;, &#x27;js: 1234567&#x27;))</span><br><span class="line">        ReactDOM.render(VDOM1, document.getElementById(&quot;text&quot;))</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="虚拟DOM的特点"><a href="#虚拟DOM的特点" class="headerlink" title="虚拟DOM的特点"></a>虚拟DOM的特点</h1><ul>
<li>本质是Object类型的对象</li>
<li>虚拟DOM属性比真实DOM少很多，虚拟DOM在React内部使用，不需要那么多的属性</li>
<li>虚拟DOM最终会被React转化为真实DOM,呈现在页面上</li>
</ul>
<h1 id="jsx语法："><a href="#jsx语法：" class="headerlink" title="jsx语法："></a>jsx语法：</h1><ul>
<li>定义虚拟DOM,不要写引号</li>
<li>标签混入JS表达式，要用花括号{} 【虚拟DOM里插入变量： {变量}】</li>
<li>样式的类名指定要用className,不是class</li>
<li>内联样式的写法<code>style=&#123;&#123;color:'pink',fontSize:'30px'&#125;&#125;</code></li>
<li>根标签只能有一个</li>
<li>标签必须闭合</li>
<li>标签首字母<ul>
<li>小写开头，转成html同名元素，若无则报错【例：<good> 】</li>
<li>大写开头，React就会渲染对应的组件，组件没有定义，则报错<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;使用js和jsx创建虚拟DOM&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;text&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">        const myId = &#x27;tiTlE&#x27;</span><br><span class="line">        const myData = &#x27;tiTlE_IteM&#x27;</span><br><span class="line">        // 虚拟DOM里插入变量： &#123;变量&#125;</span><br><span class="line">        // myId.toLowerCase() 字符串小写</span><br><span class="line">        const VDOM = (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1 className=&#x27;title&#x27; id=&#123;myId.toLowerCase()&#125;&gt;</span><br><span class="line">                    &lt;span style=&#123;&#123; color: &#x27;pink&#x27;, fontSize: &#x27;30px&#x27; &#125;&#125; id=&#123;myData.toLowerCase()&#125;&gt;jsx:123456&lt;/span&gt;</span><br><span class="line">                &lt;/h1&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">        ReactDOM.render(VDOM, document.getElementById(&quot;app&quot;))</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .title &#123;</span><br><span class="line">            background-color: royalblue;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>JS表达式:一个表达式会产生一个值，可以放在任何一个需要值的地方</strong><br><strong>例如</strong></p>
<ul>
<li>a</li>
<li>a+b</li>
<li>demo(1)</li>
<li>arr.map()</li>
<li>function test () { }</li>
</ul>
</blockquote>
<blockquote>
<p><strong>JS语句(代码)</strong><br><strong>例如</strong></p>
<ul>
<li>if(){}</li>
<li>for(){}</li>
<li>switch(){case:xxx}</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">        // 模拟数据</span><br><span class="line">        const data = [&#x27;A&#x27;,&#x27;Vue&#x27;,&#x27;React&#x27;]</span><br><span class="line">        const VDOM = (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;前端框架爱&lt;/h2&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        data.map((item,index) =&gt; &#123;return &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt;&#125;)</span><br><span class="line">                    &#125;</span><br><span class="line">                    &lt;li&gt;Ang&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;Vue&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;React&lt;/li&gt;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">        ReactDOM.render(VDOM, document.getElementById(&quot;app&quot;))</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h1 id="模块与组件"><a href="#模块与组件" class="headerlink" title="模块与组件"></a>模块与组件</h1><p>模块理解：向外提供特定功能的js程序,一个js文件就是模块<br>作用:复用js，简化js编写，提高js运行效率，降低耦合性</p>
<p>组件理解：用来实现局部功能效果的代码和资源的集合<br>作用：复用编码，简化项目编程，提高运行效率</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React知识点————React应用与ajax【第三章、第四章】</title>
    <url>/2021/12/30/03.React/</url>
    <content><![CDATA[<h1 id="github用户搜索-案例"><a href="#github用户搜索-案例" class="headerlink" title="github用户搜索 案例"></a>github用户搜索 案例</h1><p><strong>解决跨域</strong></p>
<ul>
<li> package.json 里添加 proxy, “proxy”: “<a href="http://localhost:5000&quot;">http://localhost:5000&quot;</a></li>
</ul>
<p><strong>连续解构赋值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 正常写法</span><br><span class="line">let obj = &#123;a:&#123;b:&#123;c:1&#125;&#125;&#125;</span><br><span class="line">let obj2 = &#123;a:&#123;b:88&#125;&#125;</span><br><span class="line">console.log(obj.a.b.c);</span><br><span class="line">// 连续解构赋值 </span><br><span class="line">const &#123;a:&#123;b:&#123;c&#125;&#125;&#125; = obj</span><br><span class="line">console.log(c);</span><br><span class="line">// 连续解构赋值 + 重命名</span><br><span class="line">const &#123;a:&#123;b:data&#125;&#125; = obj2</span><br><span class="line">console.log(data);</span><br></pre></td></tr></table></figure>

<h1 id="消息订阅——发布机制-pubsub-js"><a href="#消息订阅——发布机制-pubsub-js" class="headerlink" title="消息订阅——发布机制 pubsub-js"></a>消息订阅——发布机制 pubsub-js</h1><p><strong>pubsub-js作用:用于任意页面之间的通信(订阅发布:先发布后订阅)</strong><br>用法：<br>1.发布  PubSub.publish(‘switchMusic’, type);<br>2.订阅 PubSub.subscribe(‘switchMusic’, (msg, data) =&gt; {<br>            console.log(data)<br>       })<br>PubSub.subscribe会触发多次（每订阅一次，数据就会累加，需求只需订阅一次时使用）<br>3.取消订阅 <code>PubSub.unsubscribe(&#39;switchMusic&#39;)</code> React【componentWillUnmount】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">	this.token = PubSub.subscribe(&#x27;data&#x27;, (msg, data) =&gt; &#123;</span><br><span class="line">		this.setState(&#123;</span><br><span class="line">			...data</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line">componentWillUnmount()&#123;</span><br><span class="line">	console.log(&#x27;卸载&#x27;,this.token);</span><br><span class="line">	PubSub.unsubscribe(this.token)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="React-ajax【第四章】"><a href="#React-ajax【第四章】" class="headerlink" title="React ajax【第四章】"></a>React ajax【第四章】</h1><ul>
<li>xhr 和 fetch</li>
<li>xhr 封装的库：axios实现异步加载</li>
<li>fetch：fetch实现异步加载<h1 id="fetch发送请求-（关注分离的设计思想）"><a href="#fetch发送请求-（关注分离的设计思想）" class="headerlink" title="fetch发送请求 （关注分离的设计思想）"></a>fetch发送请求 （关注分离的设计思想）</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// try catch 获取await的错误情况</span><br><span class="line">try &#123;</span><br><span class="line">	let data = await fetch(`https://api.github.com/search/users?q=$&#123;keyWord&#125;`)</span><br><span class="line">	let response = await data.json()</span><br><span class="line">	PubSub.publish(&#x27;data&#x27;, &#123; isLoading: false, users: response.items &#125;);</span><br><span class="line">	console.log(response);</span><br><span class="line">&#125; catch (error) &#123;</span><br><span class="line">	console.log(error);</span><br><span class="line">	PubSub.publish(&#x27;data&#x27;, &#123;isLoading:false,err:error.message&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// axios实现异步加载</span><br><span class="line">axios.get(`https://api.github.com/search/users?q=$&#123;keyWord&#125;`).then(</span><br><span class="line">	response =&gt; &#123;</span><br><span class="line">		PubSub.publish(&#x27;data&#x27;, &#123;isLoading:false,users:response.data.items&#125;);</span><br><span class="line">	&#125;,</span><br><span class="line">	error =&gt; &#123;</span><br><span class="line">		PubSub.publish(&#x27;data&#x27;, &#123;isLoading:false,err:error.message&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React知识点————面向组件编程【第二章】</title>
    <url>/2021/12/30/02.React/</url>
    <content><![CDATA[<h1 id="基本理解和使用"><a href="#基本理解和使用" class="headerlink" title="基本理解和使用"></a>基本理解和使用</h1><ul>
<li>函数式组件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">    // 1.创建函数式组件【组件：包含html,js,css等等】</span><br><span class="line">    function MyComponent()&#123;</span><br><span class="line">        console.log(this); // undefined   babel编译后，开启了严格模式</span><br><span class="line">        return &lt;h2&gt;我使用函数定义的组件（适用于【简单函数】的定义）&lt;/h2&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    // 2.渲染组件到页面</span><br><span class="line">    // 不能写函数名【写标签,开头大写,标签闭合】</span><br><span class="line">    ReactDOM.render(&lt;MyComponent/&gt;,document.getElementById(&#x27;app&#x27;))</span><br><span class="line">    /*</span><br><span class="line">        执行了ReactDOM.render() .........之后，发生了什么？</span><br><span class="line">        1.React解析组件标签，找到 MyComponent 组件</span><br><span class="line">        2.发现组件是用函数定义的，调用该组件，将返回的虚拟DOM转为真实的DOM，随后呈现在页面中</span><br><span class="line">    */</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt; </span><br></pre></td></tr></table></figure></li>
<li>类式组件<ul>
<li>类的基本使用<ul>
<li>类中的构造器不是必须写的，要对实例进行一些初始化的操作，如添加指定属性时才写</li>
<li>如果A类继承了B类，且A类中写了构造器，那么A类构造器中的super是必须要调用的</li>
<li>类中所定义的方法，都是放在了类的原型对象上，供实例去使用<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   // 定义一个类</span><br><span class="line">class Person&#123;</span><br><span class="line">    // 构造器</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        // this是类的实例对象【lisi】</span><br><span class="line">        this.name = name</span><br><span class="line">        this.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    speak()&#123;</span><br><span class="line">        // 通过Person实例调用speak,speak中的this就是Person实例</span><br><span class="line">        console.log(`$&#123;this.name&#125;在说话`);  ————类的原型对象上，供实例使用</span><br><span class="line">    &#125;</span><br><span class="line">    info()&#123;</span><br><span class="line">        console.log(`我的名字$&#123;this.name&#125;,今年$&#123;this.age&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    constructor(name,age,grade)&#123;</span><br><span class="line">        super(name,age)</span><br><span class="line">        this.grade = grade</span><br><span class="line">    &#125;</span><br><span class="line">    info()&#123;</span><br><span class="line">        console.log(`我的名字$&#123;this.name&#125;,今年$&#123;this.age&#125;,$&#123;this.grade&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let s1 = new Student(&#x27;小明&#x27;,23)</span><br><span class="line">let s2 = new Student(&#x27;李四&#x27;,20,&#x27;大一&#x27;)</span><br><span class="line">s1.info()</span><br><span class="line">s1.speak()</span><br><span class="line">s2.info()</span><br><span class="line">s2.speak()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">        // 1.创建类式组件</span><br><span class="line">        class MyComponent extends React.Component &#123;</span><br><span class="line">            render()&#123;</span><br><span class="line">                // render是放在哪里的？ ————MyComponent的原型对象上，供实例使用</span><br><span class="line">                // render中的this是谁？ ————MyComponent的实例对象【MyComponent组件实例对象】</span><br><span class="line">                console.log(123,this);</span><br><span class="line">                return &lt;h2&gt;我使用类定义的组件（适用于【复杂函数】的定义）&lt;/h2&gt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 2.渲染组件到页面</span><br><span class="line">        ReactDOM.render(&lt;MyComponent/&gt;,document.getElementById(&#x27;app&#x27;))</span><br><span class="line">    /*</span><br><span class="line">        执行了ReactDOM.render() .........之后，发生了什么？</span><br><span class="line">        1.React解析组件标签，找到 MyComponent 组件</span><br><span class="line">        2.发现组件是用类定义的，随后 new 出来该类【MyComponent】的实例，通过该实例调用原型上的方法【render】</span><br><span class="line">        3.将 render 返回的虚拟DOM转为真实的DOM，随后呈现在页面中</span><br><span class="line">    */</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="组件实例【类式组件】三大核心属性：state【状态】"><a href="#组件实例【类式组件】三大核心属性：state【状态】" class="headerlink" title="组件实例【类式组件】三大核心属性：state【状态】"></a>组件实例【类式组件】三大核心属性：state【状态】</h1><p><strong>state是组件对象最重要的属性，值是对象</strong><br><strong>组件被称为 “状态机” ,通过更新组件的 state 来更新对应的页面（重新渲染组件）</strong></p>
<ul>
<li>组件中 render 的this为组件实例对象</li>
<li>组件中的自定义方法的 this 为undefined【解决：1.bind()方法 2.箭头函数】</li>
<li>状态数据不能直接修改和更新<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button id=&quot;btn1&quot;&gt;按钮1&lt;/button&gt;</span><br><span class="line">    &lt;button id=&quot;btn2&quot;&gt;按钮2&lt;/button&gt;</span><br><span class="line">    &lt;button id=&quot;btn3&quot; onclick=&quot;demo()&quot;&gt;按钮3&lt;/button&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        const  btn1 = document.getElementById(&#x27;btn1&#x27;)</span><br><span class="line">        btn1.addEventListener(&#x27;click&#x27;,()=&gt; &#123;</span><br><span class="line">            alert(&#x27;按钮1被点击&#x27;)    </span><br><span class="line">        &#125;)</span><br><span class="line">        btn2.onclick = () =&gt; &#123;</span><br><span class="line">            alert(&#x27;按钮2被点击&#x27;)    </span><br><span class="line">        &#125;</span><br><span class="line">        function demo()&#123;</span><br><span class="line">            alert(&#x27;按钮3被点击&#x27;)    </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 类中的实例调用 与 直接调用</span><br><span class="line">        class Person &#123;</span><br><span class="line">            constructor(name,age)&#123;</span><br><span class="line">                this.name = name</span><br><span class="line">                this.age = age</span><br><span class="line">            &#125;</span><br><span class="line">            speak()&#123;</span><br><span class="line">                console.log(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        let p1 = new Person(&#x27;小明&#x27;,18)</span><br><span class="line">        // 实例调用</span><br><span class="line">        p1.speak() // Person的实例对象</span><br><span class="line">        // 直接调用</span><br><span class="line">        let x = p1.speak</span><br><span class="line">        console.log(&#x27;直接调用&#x27;,x); // 函数</span><br><span class="line"></span><br><span class="line">        // undefined 严格模式下this为undefined</span><br><span class="line">        // 不开启this指向window</span><br><span class="line">        function text()&#123;</span><br><span class="line">            // &#x27;use strict&#x27;</span><br><span class="line">            console.log(this);</span><br><span class="line">        &#125;</span><br><span class="line">        text() </span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">        class Weather extends React.Component &#123;</span><br><span class="line">            // 构造器调用几次? ————————1次 【只用了一次Weather标签，只new出来一个实例对象】</span><br><span class="line">            // 构造器的作用：1.初始化状态 2.修改this指向</span><br><span class="line">            constructor(props) &#123;</span><br><span class="line">                console.log(&#x27;constructor&#x27;);</span><br><span class="line">                super(props)</span><br><span class="line">                // 初始化状态</span><br><span class="line">                this.state = &#123; isHot: false ,wind:&#x27;微风&#x27;&#125;</span><br><span class="line">                // bind改变this的指向,解决changeWeather中的this指向问题</span><br><span class="line">                this.changeWeather = this.changeWeather.bind(this)</span><br><span class="line">            &#125;</span><br><span class="line">            // render调用几次? ————————1+n次【每次修改状态，就会render一次（1是初识渲染，n是状态更新次数）】</span><br><span class="line">            // render的作用：1.从状态里读取数据 2.根据状态值做展示</span><br><span class="line">            render() &#123;</span><br><span class="line">                console.log(&#x27;render&#x27;);</span><br><span class="line">                const &#123; isHot,wind &#125; = this.state</span><br><span class="line">                return (</span><br><span class="line">                    &lt;h1&gt;今天天气很&lt;span onClick=&#123;this.changeWeather&#125;&gt;&#123;isHot ? &#x27;炎热&#x27; : &#x27;寒冷&#x27;&#125;,&#123;wind&#125;&lt;/span&gt;&lt;/h1&gt;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            // 由于 changeWeather 是作为 onClick 的回调，所以不是通过实例调用的，是直接调用</span><br><span class="line">            // 类中的方法默认开启了局部的严格模式</span><br><span class="line">            // changeWeather() &#123; console.log(this); &#125; // 为什么demo里的this是undefined ？ ————————Weather实例没有调用demo</span><br><span class="line">            // render调用几次? ————————点几次，调几次</span><br><span class="line">            changeWeather() &#123;</span><br><span class="line">                // 通过 Weather 实例调用 changeWeather 时，changeWeather中的this就是Weather实例</span><br><span class="line">                // 注意： React.js不允许直接更改 state 里的数据 【例如： this.state.isHot = !this.state.isHot】</span><br><span class="line">                // 注意： 状态必须通过 setState 进行更改,且更新是一种合并，以前的数据不会丢失</span><br><span class="line">                this.setState(&#123;</span><br><span class="line">                    isHot:!this.state.isHot</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ReactDOM.render(&lt;Weather /&gt;, document.getElementById(&#x27;app&#x27;))</span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
<li><em>简写state</em>*<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">        class Weather extends React.Component &#123;</span><br><span class="line">            // 初始化状态</span><br><span class="line">            state = &#123; isHot: false, wind: &#x27;微风&#x27; &#125;</span><br><span class="line">            render() &#123;</span><br><span class="line">                const &#123; isHot, wind &#125; = this.state</span><br><span class="line">                return (</span><br><span class="line">                    &lt;h1&gt;今天天气很&lt;span onClick=&#123;this.changeWeather&#125;&gt;&#123;isHot ? &#x27;炎热&#x27; : &#x27;寒冷&#x27;&#125;,&#123;wind&#125;&lt;/span&gt;&lt;/h1&gt;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            // 自定义方法</span><br><span class="line">            changeWeather = () =&gt; &#123;</span><br><span class="line">                this.setState(&#123;</span><br><span class="line">                    isHot: !this.state.isHot</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ReactDOM.render(&lt;Weather /&gt;, document.getElementById(&#x27;app&#x27;))</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="组件实例【类式组件】三大核心属性：props"><a href="#组件实例【类式组件】三大核心属性：props" class="headerlink" title="组件实例【类式组件】三大核心属性：props"></a>组件实例【类式组件】三大核心属性：props</h1><p><strong>基本使用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;app1&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">        class Weather extends React.Component &#123;</span><br><span class="line">            render() &#123;</span><br><span class="line">                return (</span><br><span class="line">                    &lt;div &gt;</span><br><span class="line">                        &lt;ul&gt;</span><br><span class="line">                            &lt;li&gt;姓名:&#123;this.props.name&#125;&lt;/li&gt;</span><br><span class="line">                            &lt;li&gt;性别:&#123;this.props.gender&#125;&lt;/li&gt;</span><br><span class="line">                            &lt;li&gt;年龄:&#123;this.props.age&#125;&lt;/li&gt;</span><br><span class="line">                        &lt;/ul&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ReactDOM.render(&lt;Weather name=&quot;lisi&quot; gender=&#x27;男&#x27; age=&#x27;23&#x27; /&gt;, document.getElementById(&#x27;app&#x27;))</span><br><span class="line">        ReactDOM.render(&lt;Weather name=&quot;wangwu&quot; gender=&#x27;女&#x27; age=&#x27;18&#x27; /&gt;, document.getElementById(&#x27;app1&#x27;))</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><strong>扩展运算符</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        // 构造字面量对象时使用展开语法</span><br><span class="line">        let person = &#123;</span><br><span class="line">            name: &#x27;张三&#x27;,</span><br><span class="line">            gender: &#x27;男&#x27;,</span><br><span class="line">            age: 18,</span><br><span class="line">            cars:[&#x27;奔驰&#x27;,&#x27;宝马&#x27;,&#x27;长安&#x27;]</span><br><span class="line">        &#125;</span><br><span class="line">        let student = &#123;</span><br><span class="line">            name: &#x27;张三san&#x27;,</span><br><span class="line">            grade:&#x27;高三&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        let person1 = &#123;...person&#125;</span><br><span class="line">        // 进行拷贝，浅层拷贝</span><br><span class="line">        person1.cars[1] = &#x27;奔驰1111111&#x27;</span><br><span class="line">        person.name = &#x27;张三3333&#x27;</span><br><span class="line">        console.log(person);</span><br><span class="line">        console.log(person1);</span><br><span class="line">        console.log(&#123;...person,...student&#125;);</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><strong>对props进行限制</strong></p>
<ul>
<li>添加类的规则写法：类名.propTypes = {} 例如：Person.propTypes = {id: PropTypes.number.isRequired}</li>
<li>默认的标签属性值写法：类名.defaultProps = {}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 用于支持React操作DOM --&gt;</span><br><span class="line">&lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 用于jsx转js --&gt;</span><br><span class="line">&lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 用于对属性标签数据限制 --&gt;</span><br><span class="line">&lt;script src=&quot;./js/prop-types.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">    class Person extends React.Component &#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            let &#123; name, gender, age &#125; = this.props</span><br><span class="line">            return (</span><br><span class="line">                &lt;div &gt;</span><br><span class="line">                    &lt;ul&gt;</span><br><span class="line">                        &lt;li&gt;姓名:&#123;name&#125;&lt;/li&gt;</span><br><span class="line">                        &lt;li&gt;性别:&#123;gender&#125;&lt;/li&gt;</span><br><span class="line">                        &lt;li&gt;年龄:&#123;age + 1&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;/ul&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 添加类的规则【对标签属性进行类型、必要性的限制】</span><br><span class="line">    // isRequired必传 defaultProps默认值</span><br><span class="line">    Person.propTypes = &#123;</span><br><span class="line">        name: PropTypes.string.isRequired,</span><br><span class="line">        gender: PropTypes.string,</span><br><span class="line">        age: PropTypes.number,</span><br><span class="line">        speak: PropTypes.func,</span><br><span class="line">    &#125;</span><br><span class="line">    // 指定默认的标签属性值</span><br><span class="line">    Person.defaultProps = &#123;</span><br><span class="line">        gender: &#x27;男&#x27;,</span><br><span class="line">        age: 18</span><br><span class="line">    &#125;</span><br><span class="line">    let data = &#123;</span><br><span class="line">        name: &#x27;12&#x27;,</span><br><span class="line">        gender: &#x27;男&#x27;,</span><br><span class="line">        age: 18</span><br><span class="line">    &#125;</span><br><span class="line">    // &#123;...data&#125; 的花括号是作为分割符在使用 相当于 ...data</span><br><span class="line">    ReactDOM.render(&lt;Person name=&#x27;222&#x27; gender=&#x27;女&#x27; age=&#123;18&#125;  speak=&#123;speak&#125;/&gt;, document.getElementById(&#x27;app&#x27;))</span><br><span class="line">    ReactDOM.render(&lt;Person &#123;...data&#125; /&gt;, document.getElementById(&#x27;app1&#x27;))</span><br><span class="line"></span><br><span class="line">    function speak()&#123;</span><br><span class="line">        console.log(&#x27;说话了&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>简写props</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div id=&quot;app1&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;!-- 用于支持React操作DOM --&gt;</span><br><span class="line">  &lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;!-- 用于jsx转js --&gt;</span><br><span class="line">  &lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;!-- 用于对属性标签数据限制 --&gt;</span><br><span class="line">  &lt;script src=&quot;./js/prop-types.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">      class Person extends React.Component &#123;</span><br><span class="line">          // 给Person自身添加一个属性 propTypes</span><br><span class="line"></span><br><span class="line">          // 添加类的规则【对标签属性进行类型、必要性的限制】</span><br><span class="line">          // isRequired必传 defaultProps默认值</span><br><span class="line">          static propTypes = &#123;</span><br><span class="line">              name: PropTypes.string.isRequired,</span><br><span class="line">              gender: PropTypes.string,</span><br><span class="line">              age: PropTypes.number,</span><br><span class="line">              speak: PropTypes.func,</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // 给Person自身添加一个属性 defaultProps</span><br><span class="line">          // 指定默认的标签属性值</span><br><span class="line">          static defaultProps = &#123;</span><br><span class="line">              gender: &#x27;男&#x27;,</span><br><span class="line">              age: 18</span><br><span class="line">          &#125;</span><br><span class="line">          render() &#123;</span><br><span class="line">              let &#123; name, gender, age &#125; = this.props</span><br><span class="line">              // this.props.name = &#x27;Tom&#x27; // 报错 props是只读的</span><br><span class="line">              return (</span><br><span class="line">                  &lt;div &gt;</span><br><span class="line">                      &lt;ul&gt;</span><br><span class="line">                          &lt;li&gt;姓名:&#123;name&#125;&lt;/li&gt;</span><br><span class="line">                          &lt;li&gt;性别:&#123;gender&#125;&lt;/li&gt;</span><br><span class="line">                          &lt;li&gt;年龄:&#123;age + 1&#125;&lt;/li&gt;</span><br><span class="line">                      &lt;/ul&gt;</span><br><span class="line">                  &lt;/div&gt;</span><br><span class="line">              )</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      let data = &#123;</span><br><span class="line">          name: &#x27;12&#x27;,</span><br><span class="line">          gender: &#x27;男&#x27;,</span><br><span class="line">          age: 18</span><br><span class="line">      &#125;</span><br><span class="line">      // &#123;...data&#125; 的花括号是作为分割符在使用 相当于 ...data</span><br><span class="line">      ReactDOM.render(&lt;Person name=&#x27;222&#x27; gender=&#x27;女&#x27; age=&#123;18&#125; speak=&#123;speak&#125; /&gt;, document.getElementById(&#x27;app&#x27;))</span><br><span class="line">      ReactDOM.render(&lt;Person &#123;...data&#125; /&gt;, document.getElementById(&#x27;app1&#x27;))</span><br><span class="line"></span><br><span class="line">      function speak() &#123;</span><br><span class="line">          console.log(&#x27;说话了&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>构造器的注意事项</strong></p>
<ul>
<li>构造器是否接收 props ,是否传递给 super ，取决于：是否希望在构造器中通过this访问props</li>
<li>当 constructor 不传 props,super也不接收 props ,通过实例访问props【this.props】 则为 undefined<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- 用于支持React操作DOM --&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- 用于jsx转js --&gt;</span><br><span class="line">    &lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- 用于对属性标签数据限制 --&gt;</span><br><span class="line">    &lt;script src=&quot;./js/prop-types.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">        class Person extends React.Component &#123;</span><br><span class="line">            // constructor 尽量不写构造器</span><br><span class="line">            constructor(props)&#123;</span><br><span class="line">                // 构造器是否接收 props ,是否传递给 super ，取决于：是否希望在构造器中通过this访问props</span><br><span class="line">                super(props)</span><br><span class="line">                // 1.当 constructor 不传 props,super也不接收 props ,通过实例访问props【this.props】 则为 undefined</span><br><span class="line">                console.log(props);</span><br><span class="line">            &#125;</span><br><span class="line">            // 给Person自身添加一个属性 propTypes</span><br><span class="line">            // 添加类的规则【对标签属性进行类型、必要性的限制】</span><br><span class="line">            // isRequired必传 defaultProps默认值</span><br><span class="line">            static propTypes = &#123;</span><br><span class="line">                name: PropTypes.string.isRequired,</span><br><span class="line">                gender: PropTypes.string,</span><br><span class="line">                age: PropTypes.number</span><br><span class="line">            &#125;</span><br><span class="line">            // 给Person自身添加一个属性 defaultProps</span><br><span class="line">            // 指定默认的标签属性值</span><br><span class="line">            static defaultProps = &#123;</span><br><span class="line">                gender: &#x27;男&#x27;,</span><br><span class="line">                age: 18</span><br><span class="line">            &#125;</span><br><span class="line">            render() &#123;</span><br><span class="line">                let &#123; name, gender, age &#125; = this.props</span><br><span class="line">                // this.props.name = &#x27;Tom&#x27; // 报错 props是只读的</span><br><span class="line">                return (</span><br><span class="line">                    &lt;div &gt;</span><br><span class="line">                        &lt;ul&gt;</span><br><span class="line">                            &lt;li&gt;姓名:&#123;name&#125;&lt;/li&gt;</span><br><span class="line">                            &lt;li&gt;性别:&#123;gender&#125;&lt;/li&gt;</span><br><span class="line">                            &lt;li&gt;年龄:&#123;age + 1&#125;&lt;/li&gt;</span><br><span class="line">                        &lt;/ul&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ReactDOM.render(&lt;Person name=&#x27;222&#x27;  /&gt;, document.getElementById(&#x27;app&#x27;))</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>函数式组件只能使用 props</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 用于支持React操作DOM --&gt;</span><br><span class="line">&lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 用于jsx转js --&gt;</span><br><span class="line">&lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 用于对属性标签数据限制 --&gt;</span><br><span class="line">&lt;script src=&quot;./js/prop-types.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">    // 类式组件</span><br><span class="line">    class Person extends React.Component &#123;</span><br><span class="line">        static propTypes = &#123;</span><br><span class="line">            name: PropTypes.string.isRequired,</span><br><span class="line">            gender: PropTypes.string,</span><br><span class="line">            age: PropTypes.number</span><br><span class="line">        &#125;</span><br><span class="line">        static defaultProps = &#123;</span><br><span class="line">            gender: &#x27;男&#x27;,</span><br><span class="line">            age: 18</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            let &#123; name, gender, age &#125; = this.props</span><br><span class="line">            return (</span><br><span class="line">                &lt;div &gt;</span><br><span class="line">                    &lt;ul&gt;</span><br><span class="line">                        &lt;li&gt;姓名:&#123;name&#125;&lt;/li&gt;</span><br><span class="line">                        &lt;li&gt;性别:&#123;gender&#125;&lt;/li&gt;</span><br><span class="line">                        &lt;li&gt;年龄:&#123;age + 1&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;/ul&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 函数式组件</span><br><span class="line">    function Person1(props) &#123;</span><br><span class="line">        let &#123; name, gender, age &#125; = props</span><br><span class="line">        return (</span><br><span class="line">            &lt;div &gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li&gt;姓名:&#123;name&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;性别:&#123;gender&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;年龄:&#123;age + 1&#125;&lt;/li&gt;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    Person1.propTypes = &#123;</span><br><span class="line">        name: PropTypes.string.isRequired,</span><br><span class="line">        gender: PropTypes.string,</span><br><span class="line">        age: PropTypes.number</span><br><span class="line">    &#125;</span><br><span class="line">    Person1.defaultProps = &#123;</span><br><span class="line">        gender: &#x27;男&#x27;,</span><br><span class="line">        age: 18</span><br><span class="line">    &#125;</span><br><span class="line">    ReactDOM.render(&lt;Person name=&#x27;222&#x27; /&gt;, document.getElementById(&#x27;app&#x27;))</span><br><span class="line">    ReactDOM.render(&lt;Person1 name=&#x27;李四&#x27; gender=&#x27;男&#x27; age=&#123;22&#125; /&gt;, document.getElementById(&#x27;app1&#x27;))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<h1 id="组件实例【类式组件】三大核心属性：refs-与事件处理"><a href="#组件实例【类式组件】三大核心属性：refs-与事件处理" class="headerlink" title="组件实例【类式组件】三大核心属性：refs 与事件处理"></a>组件实例【类式组件】三大核心属性：refs 与事件处理</h1><ul>
<li>refs理解: 组件内的标签可以定义 ref 来标识自己</li>
<li>字符串类型的ref写法:  ref=’标识名’ 【不太推荐使用】<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;!-- 用于支持React操作DOM --&gt;</span><br><span class="line">  &lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;!-- 用于jsx转js --&gt;</span><br><span class="line">  &lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;!-- 用于对属性标签数据限制 --&gt;</span><br><span class="line">  &lt;script src=&quot;./js/prop-types.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">      // 类式组件</span><br><span class="line">      class Person extends React.Component &#123;</span><br><span class="line">          render() &#123;</span><br><span class="line">              let &#123; name &#125; = this.props</span><br><span class="line">              return (</span><br><span class="line">                  &lt;div&gt;</span><br><span class="line">                      &lt;input ref=&#x27;input&#x27; placeholder=&#x27;点击按钮提示数据&#x27; type=&quot;text&quot;/&gt;&amp;nbsp;</span><br><span class="line">                      &lt;button ref=&#x27;btn1&#x27; onClick=&#123;this.open&#125;&gt;按钮&lt;/button&gt;&amp;nbsp;</span><br><span class="line">                      &lt;input ref=&#x27;input1&#x27; placeholder=&#x27;失去焦点提示数据&#x27; type=&quot;text&quot;  onBlur=&#123;this.showData&#125;/&gt;</span><br><span class="line">                  &lt;/div&gt;</span><br><span class="line">              )</span><br><span class="line">          &#125;</span><br><span class="line">          open = () =&gt; &#123;</span><br><span class="line">              // 是真实节点DOM，而不是虚拟DOM</span><br><span class="line">              // console.log(this.refs.input);</span><br><span class="line">              let &#123;input&#125; = this.refs</span><br><span class="line">              alert(input.value)</span><br><span class="line">          &#125;</span><br><span class="line">          showData = () =&gt; &#123;</span><br><span class="line">              let &#123;input1&#125; = this.refs</span><br><span class="line">              alert(input1.value)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ReactDOM.render(&lt;Person name=&#x27;lisi&#x27; /&gt;, document.getElementById(&#x27;app&#x27;))</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li>回调函数形式的ref写法:  ref={c =&gt; {this.input1 = c}} 【内联函数的方式】<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">   &lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;!-- 用于支持React操作DOM --&gt;</span><br><span class="line">   &lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;!-- 用于jsx转js --&gt;</span><br><span class="line">   &lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;!-- 用于对属性标签数据限制 --&gt;</span><br><span class="line">   &lt;script src=&quot;./js/prop-types.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">       class Person extends React.Component &#123;</span><br><span class="line">           render() &#123;</span><br><span class="line">               let &#123; name &#125; = this.props</span><br><span class="line">               return (</span><br><span class="line">                   &lt;div&gt;</span><br><span class="line">                       &lt;input ref=&#123;c =&gt; this.input = c&#125; placeholder=&#x27;点击按钮提示数据&#x27; type=&quot;text&quot; /&gt;&amp;nbsp;</span><br><span class="line">                       &lt;button ref=&#x27;btn1&#x27; onClick=&#123;this.open&#125;&gt;按钮&lt;/button&gt;&amp;nbsp;</span><br><span class="line">                       &lt;input ref=&#123;c =&gt; this.input1 = c&#125; placeholder=&#x27;失去焦点提示数据&#x27; type=&quot;text&quot; onBlur=&#123;this.showData&#125; /&gt;</span><br><span class="line">                   &lt;/div&gt;</span><br><span class="line">               )</span><br><span class="line">           &#125;</span><br><span class="line">           open = () =&gt; &#123;</span><br><span class="line">               let &#123; input &#125; = this</span><br><span class="line">               alert(input.value)</span><br><span class="line">           &#125;</span><br><span class="line">           showData = () =&gt; &#123;</span><br><span class="line">               let &#123; input1 &#125; = this</span><br><span class="line">               alert(input1.value)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ReactDOM.render(&lt;Person name=&#x27;lisi&#x27; /&gt;, document.getElementById(&#x27;app&#x27;))</span><br></pre></td></tr></table></figure></li>
<li>内联函数的方式:回调ref中回调次数的问题【解决：类绑定函数的方式：ref={this.textFnc}}】<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- 用于支持React操作DOM --&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- 用于jsx转js --&gt;</span><br><span class="line">    &lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- 用于对属性标签数据限制 --&gt;</span><br><span class="line">    &lt;script src=&quot;./js/prop-types.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">        // 回调ref中回调次数的问题</span><br><span class="line">        class Person extends React.Component &#123;</span><br><span class="line">            state = &#123;</span><br><span class="line">                isHot: false</span><br><span class="line">            &#125;</span><br><span class="line">            open = () =&gt; &#123;</span><br><span class="line">                let &#123; input &#125; = this</span><br><span class="line">                alert(input.value)</span><br><span class="line">            &#125;</span><br><span class="line">            ChangeWeather = () =&gt; &#123;</span><br><span class="line">                this.setState(&#123;</span><br><span class="line">                    isHot: !this.state.isHot</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            // 通过将 ref 的回调函数定义成 class 的绑定函数的方式</span><br><span class="line">            // 不会再重复调用saveInput</span><br><span class="line">            saveInput = (c) =&gt; &#123;</span><br><span class="line">                this.input = c </span><br><span class="line">                console.log(&quot;123&quot;,c)</span><br><span class="line">            &#125;</span><br><span class="line">            render() &#123;</span><br><span class="line"></span><br><span class="line">                let &#123; isHot &#125; = this.state</span><br><span class="line">                let &#123; name &#125; = this.props</span><br><span class="line">                // c页面更新后会调用连词，第一次为null,第二次才会返回节点</span><br><span class="line">                // jsx注释 &#123;/* */&#125;</span><br><span class="line">                // 通过将 ref 的回调函数定义成 class 的绑定函数的方式</span><br><span class="line">                return (</span><br><span class="line">                    &lt;div&gt;</span><br><span class="line">                        &lt;h2&gt;今天天气很&#123;isHot ? &#x27;炎热&#x27; : &#x27;寒冷&#x27;&#125;&lt;/h2&gt;</span><br><span class="line">                        &#123;/* 内联用法比较多，即下面的方式 */&#125;</span><br><span class="line">                        &#123;/* &lt;input ref=&#123;c =&gt; &#123;this.input = c ;console.log(&quot;123&quot;,c)&#125;&#125; placeholder=&#x27;点击按钮提示数据&#x27; type=&quot;text&quot; /&gt;&amp;nbsp; */&#125;</span><br><span class="line">                        &lt;input ref=&#123;this.saveInput&#125; placeholder=&#x27;点击按钮提示数据&#x27; type=&quot;text&quot; /&gt;&amp;nbsp;</span><br><span class="line">                        &lt;button onClick=&#123;this.open&#125;&gt;按钮&lt;/button&gt;</span><br><span class="line">                        &lt;button onClick=&#123;this.ChangeWeather&#125;&gt;改变天气&lt;/button&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ReactDOM.render(&lt;Person name=&#x27;lisi&#x27; /&gt;, document.getElementById(&#x27;app&#x27;))</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li>createRef的方式 【最推荐的方式】<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 用于支持React操作DOM --&gt;</span><br><span class="line">&lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 用于jsx转js --&gt;</span><br><span class="line">&lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 用于对属性标签数据限制 --&gt;</span><br><span class="line">&lt;script src=&quot;./js/prop-types.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">    // React.createRef ；调用后可以返回一个容器，该容器可以存储被 ref 所标识的节点 &#x27;该容器是专人专用&#x27;</span><br><span class="line">    class Person extends React.Component &#123;</span><br><span class="line">        myRef = React.createRef()</span><br><span class="line">        myRef1 = React.createRef()</span><br><span class="line">        open = () =&gt; &#123;</span><br><span class="line">            alert(this.myRef.current.value)</span><br><span class="line">        &#125;</span><br><span class="line">        open1 = () =&gt; &#123;</span><br><span class="line">            alert(this.myRef1.current.value)</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;input ref=&#123;this.myRef&#125; placeholder=&#x27;点击按钮提示数据&#x27; type=&quot;text&quot; /&gt;&amp;nbsp;</span><br><span class="line">                    &lt;button onClick=&#123;this.open&#125;&gt;按钮&lt;/button&gt;&amp;nbsp;</span><br><span class="line">                    &lt;input onBlur=&#123;this.open1&#125; ref=&#123;this.myRef1&#125; placeholder=&#x27;失去焦点提示数据&#x27; type=&quot;text&quot; /&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ReactDOM.render(&lt;Person name=&#x27;lisi&#x27; /&gt;, document.getElementById(&#x27;app&#x27;))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li>事件处理<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 用于支持React操作DOM --&gt;</span><br><span class="line">&lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 用于jsx转js --&gt;</span><br><span class="line">&lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 用于对属性标签数据限制 --&gt;</span><br><span class="line">&lt;script src=&quot;./js/prop-types.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">    class Person extends React.Component &#123;</span><br><span class="line">        /*</span><br><span class="line">            1.通过 onXxx 属性指定事件处理函数 （注意大小写） </span><br><span class="line">                a. React使用的是自定义(合成)事件，而不是原生DOM事件 ——————为了更好的兼容性</span><br><span class="line">                b. React中的事件是通过 事件委托的方式 处理的（委托给组件最外层的元素）  ——————为了高效</span><br><span class="line">            2.通过 event.target 得到发生事件的DOM元素对象 【发生事件的元素正好是你要操作的元素 】 ——————不要过度的使用ref       </span><br><span class="line">        */</span><br><span class="line">        // 创建容器</span><br><span class="line">        myRef = React.createRef()</span><br><span class="line">        myRef1 = React.createRef()</span><br><span class="line">        open = () =&gt; &#123;</span><br><span class="line">            alert(this.myRef.current.value)</span><br><span class="line">        &#125;</span><br><span class="line">        // 发生事件的元素正好是你要操作的元素 </span><br><span class="line">        open1 = (e) =&gt; &#123;</span><br><span class="line">            alert(e.target.value)</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;input ref=&#123;this.myRef&#125; placeholder=&#x27;点击按钮提示数据&#x27; type=&quot;text&quot; /&gt;&amp;nbsp;</span><br><span class="line">                    &lt;button onClick=&#123;this.open&#125;&gt;按钮&lt;/button&gt;&amp;nbsp;</span><br><span class="line">                    &lt;input onBlur=&#123;this.open1&#125;  placeholder=&#x27;失去焦点提示数据&#x27; type=&quot;text&quot; /&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ReactDOM.render(&lt;Person name=&#x27;lisi&#x27; /&gt;, document.getElementById(&#x27;app&#x27;))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="收集表单数据-【受控组件、非受控组件】"><a href="#收集表单数据-【受控组件、非受控组件】" class="headerlink" title="收集表单数据 【受控组件、非受控组件】"></a>收集表单数据 【受控组件、非受控组件】</h1><ul>
<li>非受控组件: 现用现取 【页面中输入类的DOM，你是现用现取就是非受控组件】<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line"> &lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"> &lt;!-- 用于支持React操作DOM --&gt;</span><br><span class="line"> &lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"> &lt;!-- 用于jsx转js --&gt;</span><br><span class="line"> &lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"> &lt;!-- 用于对属性标签数据限制 --&gt;</span><br><span class="line"> &lt;script src=&quot;./js/prop-types.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"> &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">     /* 非受控组件 ； 现用现取 【页面中输入类的DOM，你是现用现取就是非受控组件】 */ </span><br><span class="line">     // 创建组件</span><br><span class="line">     class Login extends React.Component &#123;</span><br><span class="line">         handleSubmit = (e) =&gt; &#123;</span><br><span class="line">             e.preventDefault()  // 阻止默认事件</span><br><span class="line">             let &#123; username, password &#125; = this</span><br><span class="line">             alert(`用户名：$&#123;username.value&#125;,密码：$&#123;password.value&#125;` )</span><br><span class="line">         &#125;</span><br><span class="line">         render() &#123;</span><br><span class="line">             return (</span><br><span class="line">                 &lt;form action=&quot;http://www.wuqisuda.cn&quot; onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">                     用户名: &lt;input ref=&#123;c =&gt; this.username = c&#125; name=&quot;username&quot; type=&quot;text&quot; /&gt;</span><br><span class="line">                     密码: &lt;input ref=&#123;c =&gt; this.password = c&#125; name=&quot;password&quot; type=&quot;password&quot; /&gt;</span><br><span class="line">                     &lt;button onClick=&#123;this.open&#125;&gt;登录&lt;/button&gt;</span><br><span class="line">                 &lt;/form&gt;</span><br><span class="line">             )</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     // 渲染组件</span><br><span class="line">     ReactDOM.render(&lt;Login name=&#x27;lisi&#x27; /&gt;, document.getElementById(&#x27;app&#x27;))</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li>受控组件: 页面中输入类的DOM，随着你的输入，就能把数据维护到状态里面去【类似 vue 的 双向绑定】<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- 用于支持React操作DOM --&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- 用于jsx转js --&gt;</span><br><span class="line">    &lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- 用于对属性标签数据限制 --&gt;</span><br><span class="line">    &lt;script src=&quot;./js/prop-types.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">        /* 受控组件 ； 现用现取 【页面中输入类的DOM，随着你的输入，就能把数据维护到状态里面去】【类似 vue 的 双向绑定】 */</span><br><span class="line">        // 创建组件</span><br><span class="line">        class Login extends React.Component &#123;</span><br><span class="line">            // 初始化</span><br><span class="line">            state = &#123;</span><br><span class="line">                username: &#x27;&#x27;,</span><br><span class="line">                password: &#x27;&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">            saveUsername = (e) =&gt; &#123;</span><br><span class="line">                this.setState(&#123;</span><br><span class="line">                    username: e.target.value</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            savePassword = (e) =&gt; &#123;</span><br><span class="line">                this.setState(&#123;</span><br><span class="line">                    password: e.target.value</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            handleSubmit = (e) =&gt; &#123;</span><br><span class="line">                e.preventDefault()  // 阻止默认事件</span><br><span class="line">                let &#123; username, password &#125; = this.state</span><br><span class="line">                alert(`用户名：$&#123;username&#125;,密码：$&#123;password&#125;`)</span><br><span class="line">            &#125;</span><br><span class="line">            render() &#123;</span><br><span class="line">                return (</span><br><span class="line">                    &lt;form action=&quot;http://www.wuqisuda.cn&quot; onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">                        用户名: &lt;input onChange=&#123;this.saveUsername&#125; name=&quot;username&quot; type=&quot;text&quot; /&gt;</span><br><span class="line">                        密码: &lt;input onChange=&#123;this.savePassword&#125; name=&quot;password&quot; type=&quot;password&quot; /&gt;</span><br><span class="line">                        &lt;button onClick=&#123;this.open&#125;&gt;登录&lt;/button&gt;</span><br><span class="line">                    &lt;/form&gt;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 渲染组件</span><br><span class="line">        ReactDOM.render(&lt;Login name=&#x27;lisi&#x27; /&gt;, document.getElementById(&#x27;app&#x27;))</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>高阶函数 函数柯里化</strong> </p>
<ul>
<li>高阶函数: 符合一下2个规范中的任意一个，就是高阶函数<ol>
<li>若A函数，接收的参数是一个函数，A就是高阶函数</li>
<li>若A函数，调用的返回值是一个函数，A就是高阶函数</li>
</ol>
<ul>
<li>常见的高阶函数： Promise 、 setTimeout 、 arr.map()等 </li>
</ul>
</li>
<li>函数柯里化: 通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建组件</span><br><span class="line">        class Login extends React.Component &#123;</span><br><span class="line">            // 初始化</span><br><span class="line">            state = &#123;</span><br><span class="line">                username: &#x27;&#x27;,</span><br><span class="line">                password: &#x27;&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">            // saveFormdata接收一个 type 参数 返回一个函数 ，该函数接收一个 event 参数。在 this.setState 统一处理 【函数柯里化】</span><br><span class="line">            saveFormdata = (type) =&gt; &#123;</span><br><span class="line">                // 将 saveFormdata 返回箭头函数给 onChange 作为回调</span><br><span class="line">                // 输入用户名和密码给的是 return 的函数，所以 saveFormdata 函数没有 event </span><br><span class="line">                // 输入后触发 onChange 事件，React 把 event 传给了箭头函数</span><br><span class="line">                return (event) =&gt; &#123;</span><br><span class="line">                    this.setState(&#123;</span><br><span class="line">                        [type]:event.target.value</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleSubmit = (e) =&gt; &#123;</span><br><span class="line">                e.preventDefault()  // 阻止默认事件</span><br><span class="line">                let &#123; username, password &#125; = this.state</span><br><span class="line">                alert(`用户名：$&#123;username&#125;,密码：$&#123;password&#125;`)</span><br><span class="line">            &#125;</span><br><span class="line">            render() &#123;</span><br><span class="line">                return (</span><br><span class="line">                    &lt;form action=&quot;http://www.wuqisuda.cn&quot; onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">                        用户名: &lt;input onChange=&#123;this.saveFormdata(&#x27;username&#x27;)&#125; name=&quot;username&quot; type=&quot;text&quot; /&gt;</span><br><span class="line">                        密码: &lt;input onChange=&#123;this.saveFormdata(&#x27;password&#x27;)&#125; name=&quot;password&quot; type=&quot;password&quot; /&gt;</span><br><span class="line">                        &lt;button onClick=&#123;this.open&#125;&gt;登录&lt;/button&gt;</span><br><span class="line">                    &lt;/form&gt;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 渲染组件</span><br><span class="line">        ReactDOM.render(&lt;Login name=&#x27;lisi&#x27; /&gt;, document.getElementById(&#x27;app&#x27;))</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    // 函数柯里化</span><br><span class="line">    function sum(a) &#123;</span><br><span class="line">        return (b) =&gt; &#123;</span><br><span class="line">            return (c) =&gt; &#123;</span><br><span class="line">                return a + b + c</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let result = sum(1)(2)(3)</span><br><span class="line">    console.log(result);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li>不使用柯里化实现【内联函数】<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 不使用柯里化函数实现</span><br><span class="line">        class Login extends React.Component &#123;</span><br><span class="line">            // 初始化</span><br><span class="line">            state = &#123;</span><br><span class="line">                username: &#x27;&#x27;,</span><br><span class="line">                password: &#x27;&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">            saveFormdata = (type, event) =&gt; &#123;</span><br><span class="line">                this.setState(&#123;</span><br><span class="line">                    [type]: event.target.value</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            handleSubmit = (e) =&gt; &#123;</span><br><span class="line">                e.preventDefault()  // 阻止默认事件</span><br><span class="line">                let &#123; username, password &#125; = this.state</span><br><span class="line">                alert(`用户名：$&#123;username&#125;,密码：$&#123;password&#125;`)</span><br><span class="line">            &#125;</span><br><span class="line">            render() &#123;</span><br><span class="line">                return (</span><br><span class="line">                    &lt;form action=&quot;http://www.wuqisuda.cn&quot; onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">                        用户名: &lt;input onChange=&#123;event =&gt; this.saveFormdata(&#x27;username&#x27;,event)&#125; name=&quot;username&quot; type=&quot;text&quot; /&gt;</span><br><span class="line">                        密码: &lt;input onChange=&#123;event =&gt; this.saveFormdata(&#x27;password&#x27;,event)&#125; name=&quot;password&quot; type=&quot;password&quot; /&gt;</span><br><span class="line">                        &lt;button onClick=&#123;this.open&#125;&gt;登录&lt;/button&gt;</span><br><span class="line">                    &lt;/form&gt;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ReactDOM.render(&lt;Login name=&#x27;lisi&#x27; /&gt;, document.getElementById(&#x27;app&#x27;))</span><br></pre></td></tr></table></figure></li>
<li>对象的相关知识<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    // 在空对象里添加属性 name :&#x27;tom&#x27;</span><br><span class="line">    let a = &#x27;name&#x27;</span><br><span class="line">    let  obj = &#123;&#125; </span><br><span class="line">    // 注意错误示例：obj.a = &#x27;tom&#x27; // &#123;a :&#x27;tom&#x27;&#125;</span><br><span class="line">    obj[a] = &#x27;tom&#x27;</span><br><span class="line">    console.log( obj); // &#123;name :&#x27;tom&#x27;&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="React-的-生命周期"><a href="#React-的-生命周期" class="headerlink" title="React 的 生命周期"></a>React 的 生命周期</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 用于支持React操作DOM --&gt;</span><br><span class="line">&lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 用于jsx转js --&gt;</span><br><span class="line">&lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 用于对属性标签数据限制 --&gt;</span><br><span class="line">&lt;script src=&quot;./js/prop-types.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">    //#region </span><br><span class="line">    // 生命周期回调函数 == 生命周期钩子函数</span><br><span class="line">    //#endregion</span><br><span class="line">    class Life extends React.Component &#123;</span><br><span class="line">        state = &#123;</span><br><span class="line">            opacity: 1,</span><br><span class="line">        &#125;</span><br><span class="line">        text = () =&gt; &#123;</span><br><span class="line">            // 卸载定时器</span><br><span class="line">            // clearInterval(this.timer)</span><br><span class="line">            // 卸载组件</span><br><span class="line">            ReactDOM.unmountComponentAtNode(document.getElementById(&#x27;app&#x27;))</span><br><span class="line">        &#125;</span><br><span class="line">        // 挂载</span><br><span class="line">        componentDidMount() &#123;</span><br><span class="line">            this.timer = setInterval(() =&gt; &#123;</span><br><span class="line">                let &#123; opacity &#125; = this.state</span><br><span class="line">                if (opacity &gt;= 0) &#123;</span><br><span class="line">                    opacity -= 0.1</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    opacity = 1</span><br><span class="line">                &#125;</span><br><span class="line">                this.setState(&#123; opacity &#125;)</span><br><span class="line">            &#125;, 200)</span><br><span class="line">        &#125;</span><br><span class="line">        componentWillUnmount() &#123;</span><br><span class="line">            // 卸载定时器</span><br><span class="line">            clearInterval(this.timer)</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            let &#123; opacity &#125; = this.state</span><br><span class="line">            return (</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;h2 style=&#123;&#123; &#x27;opacity&#x27;: opacity &#125;&#125;&gt;React学不会怎么办？&lt;/h2&gt;</span><br><span class="line">                    &lt;button onClick=&#123;this.text&#125;&gt;不活了&lt;/button&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ReactDOM.render(&lt;Life name=&#x27;lisi&#x27; /&gt;, document.getElementById(&#x27;app&#x27;))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>React 的 生命周期 [旧]</p>
</blockquote>
<ul>
<li>初始化阶段：由ReactDOM.render()触发 ——————初次渲染<ol>
<li>constructor  ————构造器【数据初始化(state)】</li>
<li>componentWillMount  ————将要挂载</li>
<li>render  ————渲染</li>
<li>componentDidMount  ————挂载完毕【常用】<ul>
<li>做一些初始化的事情：发起网络请求、开启定时器、订阅消息</li>
</ul>
</li>
</ol>
</li>
<li>更新阶段： 由组件内部 this.setState() 或父组件重新 render 触发【强制更新 this.forceUpdate() : 强制更新数据钩子 ——————不走阀门】<ol>
<li>shouldComponentUpdate  ————控制更新的阀门</li>
<li>componentWillUpdate  ————将要更新</li>
<li>render  ————渲染</li>
<li>componentDidUpdate  ————更新完毕</li>
</ol>
</li>
<li>卸载组件：由ReactDOM.unmountComponentAtNode(document.getElementById(‘’))触发<ol>
<li>componentWillUnmount  ————将要卸载<ul>
<li>做一些收尾的事情：关闭定时器、取消订阅消息</li>
</ul>
</li>
</ol>
</li>
<li>父组件更新render：<ol>
<li>componentWillReceiveProps  ————组将将要接受props 【第一次接受的props不会触发componentWillReceiveProps钩子】</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render  ————子组件渲染</li>
<li>componentDidUpdate</li>
</ol>
</li>
</ul>
<p><strong>17.0.0以后 componentWillReceiveProps componentWillMount componentWillUpdate前面要加 UNSAFE_ 【即将废弃】</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 用于支持React操作DOM --&gt;</span><br><span class="line">&lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 用于jsx转js --&gt;</span><br><span class="line">&lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- 用于对属性标签数据限制 --&gt;</span><br><span class="line">&lt;script src=&quot;./js/prop-types.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">    //#region </span><br><span class="line">    // 生命周期回调函数 == 生命周期钩子函数</span><br><span class="line">    //#endregion</span><br><span class="line">    class Life extends React.Component &#123;</span><br><span class="line">        // 构造器</span><br><span class="line">        constructor(props) &#123;</span><br><span class="line">            console.log(&#x27;constructor&#x27;);</span><br><span class="line">            super(props)</span><br><span class="line">            this.state = &#123;</span><br><span class="line">                num: 0,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 卸载组件按钮的回调</span><br><span class="line">        unMount = () =&gt; &#123;</span><br><span class="line">            ReactDOM.unmountComponentAtNode(document.getElementById(&#x27;app&#x27;))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 正常更新数据按钮的回调</span><br><span class="line">        upData = () =&gt; &#123;</span><br><span class="line">            let &#123; num &#125; = this.state</span><br><span class="line">            num += 1</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                num</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        // forceUpdate()</span><br><span class="line">        // 强制更新数据钩子 ——————不走阀门</span><br><span class="line">        // 不对状态进行任何修改，更新一下</span><br><span class="line">        // 强制更新按钮的回调</span><br><span class="line">        force = () =&gt; &#123;</span><br><span class="line">            this.forceUpdate()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 组件将要挂载</span><br><span class="line">        componentWillMount() &#123;</span><br><span class="line">            console.log(&#x27;组件将要挂载，componentWillMount&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 组件挂载完毕</span><br><span class="line">        componentDidMount() &#123;</span><br><span class="line">            console.log(&#x27;组件挂载完毕，componentDidMount&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 组件将要卸载</span><br><span class="line">        componentWillUnmount() &#123;</span><br><span class="line">            console.log(&#x27;组件将要卸载，componentWillUnmount&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 控制组件更新的阀门 ————————必有返回值【不去设置都是true】【布尔值】</span><br><span class="line">        shouldComponentUpdate() &#123;</span><br><span class="line">            console.log(&#x27;控制组件更新的阀门，shouldComponentUpdate&#x27;);</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        // 组件将要更新</span><br><span class="line">        componentWillUpdate() &#123;</span><br><span class="line">            console.log(&#x27;组件将要更新，componentWillUpdate&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 组件更新完毕</span><br><span class="line">        componentDidUpdate() &#123;</span><br><span class="line">            console.log(&#x27;组件更新完毕，componentDidUpdate&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            console.log(&#x27;渲染，render&#x27;);</span><br><span class="line">            let &#123; num &#125; = this.state</span><br><span class="line">            return (</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;h2&gt;当前求和为&#123;num&#125;&lt;/h2&gt;</span><br><span class="line">                    &lt;button onClick=&#123;this.upData&#125;&gt;点我加1&lt;/button&gt;</span><br><span class="line">                    &lt;button onClick=&#123;this.unMount&#125;&gt;卸载组件&lt;/button&gt;</span><br><span class="line">                    &lt;button onClick=&#123;this.force&#125;&gt;不更改状态中的数据，强制更新&lt;/button&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class A extends React.Component &#123;</span><br><span class="line">        state = &#123; carName: &#x27;宝马&#x27; &#125;</span><br><span class="line">        changeCar = () =&gt; &#123;</span><br><span class="line">            let &#123; carName &#125; = this.state</span><br><span class="line">            carName = &#x27;奔驰&#x27;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                carName</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            console.log(&#x27;父组件组件渲染，render&#x27;);</span><br><span class="line">            let &#123; carName &#125; = this.state</span><br><span class="line">            return (</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;div&gt;A&lt;/div&gt;</span><br><span class="line">                    &lt;button onClick=&#123;this.changeCar&#125;&gt;换车&lt;/button&gt;</span><br><span class="line">                    &lt;B carName=&#123;carName&#125; /&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class B extends React.Component &#123;</span><br><span class="line">        // A组件【父组件】render </span><br><span class="line">        // 组将将要接受props 【第一次接受的props不会触发componentWillReceiveProps钩子】</span><br><span class="line">        componentWillReceiveProps(props)&#123;</span><br><span class="line">            console.log(&#x27;组将将要接受props,componentWillReceiveProps&#x27;,props);</span><br><span class="line">        &#125;</span><br><span class="line">        shouldComponentUpdate() &#123;</span><br><span class="line">            console.log(&#x27;控制组件更新的阀门，shouldComponentUpdate&#x27;);</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        // 组件将要更新</span><br><span class="line">        componentWillUpdate() &#123;</span><br><span class="line">            console.log(&#x27;组件将要更新，componentWillUpdate&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 组件更新完毕</span><br><span class="line">        componentDidUpdate() &#123;</span><br><span class="line">            console.log(&#x27;组件更新完毕，componentDidUpdate&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            console.log(&#x27;子组件渲染，render&#x27;);</span><br><span class="line">            let &#123; carName &#125; = this.props</span><br><span class="line">            return (</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;h2&gt;&#123;carName&#125;&lt;/h2&gt;</span><br><span class="line">                    &lt;div&gt;B&lt;/div&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReactDOM.render(&lt;A name=&#x27;lisi&#x27; /&gt;, document.getElementById(&#x27;app&#x27;))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>React 的 生命周期 [新]</p>
</blockquote>
<ul>
<li>初始化阶段：由ReactDOM.render()触发 ——————初次渲染<ol>
<li>constructor  ————构造器【数据初始化(state)】</li>
<li>getDerivedStateFromProps  ————从 props 得到一个派生的状态</li>
<li>render  ————渲染【常用】</li>
<li>componentDidMount  ————挂载完毕【常用】<ul>
<li>做一些初始化的事情：发起网络请求、开启定时器、订阅消息</li>
</ul>
</li>
</ol>
</li>
<li>更新阶段： 由组件内部 this.setState() 或父组件重新 render 触发【强制更新 this.forceUpdate() : 强制更新数据钩子 ——————不走阀门】<ol>
<li>getDerivedStateFromProps  ————从 props 得到一个派生的状态</li>
<li>shouldComponentUpdate  ————控制更新的阀门</li>
<li>render  ————渲染</li>
<li>getSnapshotBeforeUpdate  ————在更新之前得到快照</li>
<li>componentDidUpdate  ————更新完毕 </li>
</ol>
</li>
<li>卸载组件：由ReactDOM.unmountComponentAtNode(document.getElementById(‘’))触发<ol>
<li>componentWillUnmount  ————将要卸载【常用】<ul>
<li>做一些收尾的事情：关闭定时器、取消订阅消息</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li>static getDerivedStateFromProps(){} : 从 props 得到一个派生的状态<ul>
<li>此方法适用于罕见的用例,state 的值在任何时候都取决于 props</li>
<li>必须有返回值 state对象 或者 null</li>
</ul>
</li>
<li>getSnapshotBeforeUpdate : 在更新之前得到快照<ul>
<li>必须有返回值 snapshot值【快照值】 或者 null<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- 用于支持React操作DOM --&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- 用于jsx转js --&gt;</span><br><span class="line">    &lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- 用于对属性标签数据限制 --&gt;</span><br><span class="line">    &lt;script src=&quot;./js/prop-types.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">        //#region </span><br><span class="line">        // 生命周期回调函数 == 生命周期钩子函数</span><br><span class="line">        //#endregion</span><br><span class="line">        class Life extends React.Component &#123;</span><br><span class="line">            // 构造器</span><br><span class="line">            constructor(props) &#123;</span><br><span class="line">                console.log(&#x27;constructor&#x27;);</span><br><span class="line">                super(props)</span><br><span class="line">                this.state = &#123;</span><br><span class="line">                    num: 0,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // 卸载组件按钮的回调</span><br><span class="line">            unMount = () =&gt; &#123;</span><br><span class="line">                ReactDOM.unmountComponentAtNode(document.getElementById(&#x27;app&#x27;))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 正常更新数据按钮的回调</span><br><span class="line">            upData = () =&gt; &#123;</span><br><span class="line">                let &#123; num &#125; = this.state</span><br><span class="line">                num += 1</span><br><span class="line">                this.setState(&#123;</span><br><span class="line">                    num</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            // forceUpdate()</span><br><span class="line">            // 强制更新数据钩子 ——————不走阀门</span><br><span class="line">            // 不对状态进行任何修改，更新一下</span><br><span class="line">            // 强制更新按钮的回调</span><br><span class="line">            force = () =&gt; &#123;</span><br><span class="line">                this.forceUpdate()</span><br><span class="line">            &#125;</span><br><span class="line">            // 从 props 得到一个派生的状态</span><br><span class="line">            // 必须有返回值 state对象 或者 null</span><br><span class="line">            // 此方法适用于罕见的用例,state 的值在任何时候都取决于 props</span><br><span class="line">            static getDerivedStateFromProps(props,state)&#123;</span><br><span class="line">                console.log(&#x27;getDerivedStateFromProps&#x27;,props,state);</span><br><span class="line">                return null</span><br><span class="line">            &#125;</span><br><span class="line">            // 在更新之前得到快照</span><br><span class="line">            // 必须有返回值 snapshot值【快照值】 或者 null</span><br><span class="line">            getSnapshotBeforeUpdate(prevProps, prevState)&#123;</span><br><span class="line">                console.log(&#x27;快照，getSnapshotBeforeUpdate&#x27;,prevProps, prevState);</span><br><span class="line">                return &#x27;123123&#x27; </span><br><span class="line">            &#125;</span><br><span class="line">            // 组件挂载完毕</span><br><span class="line">            componentDidMount() &#123;</span><br><span class="line">                console.log(&#x27;组件挂载完毕，componentDidMount&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 组件将要卸载</span><br><span class="line">            componentWillUnmount() &#123;</span><br><span class="line">                console.log(&#x27;组件将要卸载，componentWillUnmount&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 控制组件更新的阀门 ————————必有返回值【不去设置都是true】【布尔值】</span><br><span class="line">            shouldComponentUpdate() &#123;</span><br><span class="line">                console.log(&#x27;控制组件更新的阀门，shouldComponentUpdate&#x27;);</span><br><span class="line">                return true</span><br><span class="line">            &#125;</span><br><span class="line">       </span><br><span class="line">            // 组件更新完毕</span><br><span class="line">            componentDidUpdate(preProps,preState,snapshotValue) &#123;</span><br><span class="line">                console.log(&#x27;组件更新完毕，componentDidUpdate&#x27;,preProps,preState,snapshotValue);</span><br><span class="line">            &#125;</span><br><span class="line">            render() &#123;</span><br><span class="line">                console.log(&#x27;渲染，render&#x27;);</span><br><span class="line">                let &#123; num &#125; = this.state</span><br><span class="line">                return (</span><br><span class="line">                    &lt;div&gt;</span><br><span class="line">                        &lt;h2&gt;当前求和为&#123;num&#125;&lt;/h2&gt;</span><br><span class="line">                        &lt;button onClick=&#123;this.upData&#125;&gt;点我加1&lt;/button&gt;</span><br><span class="line">                        &lt;button onClick=&#123;this.unMount&#125;&gt;卸载组件&lt;/button&gt;</span><br><span class="line">                        &lt;button onClick=&#123;this.force&#125;&gt;不更改状态中的数据，强制更新&lt;/button&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ReactDOM.render(&lt;Life num=&#123;99&#125; /&gt;, document.getElementById(&#x27;app&#x27;))</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>getSnapshotBeforeUpdate 应用场景：计算滚动位置</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;demo&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .list &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 150px;</span><br><span class="line">        background-color: royalblue;</span><br><span class="line">        overflow-y: auto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .news &#123;</span><br><span class="line">        height: 30px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- 用于支持React操作DOM --&gt;</span><br><span class="line">    &lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- 用于jsx转js --&gt;</span><br><span class="line">    &lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- 用于对属性标签数据限制 --&gt;</span><br><span class="line">    &lt;script src=&quot;./js/prop-types.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">        //#region </span><br><span class="line">        // 生命周期回调函数 == 生命周期钩子函数</span><br><span class="line">        //#endregion</span><br><span class="line">        class NewsList extends React.Component &#123;</span><br><span class="line">            state = &#123;</span><br><span class="line">                newsArr: [],</span><br><span class="line">            &#125;</span><br><span class="line">            clear = () =&gt; &#123;</span><br><span class="line">                clearInterval(this.timer)</span><br><span class="line">            &#125;</span><br><span class="line">            componentDidMount() &#123;</span><br><span class="line">                this.timer = setInterval(() =&gt; &#123;</span><br><span class="line">                    let &#123; newsArr &#125; = this.state</span><br><span class="line">                    // 模拟一条新闻</span><br><span class="line">                    let news = &#x27;新闻&#x27; + (newsArr.length + 1)</span><br><span class="line">                    newsArr.unshift(news)</span><br><span class="line">                    this.setState(&#123;</span><br><span class="line">                        newsArr</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;, 1000);</span><br><span class="line">            &#125;</span><br><span class="line">            getSnapshotBeforeUpdate() &#123;</span><br><span class="line">                return this.list.scrollHeight</span><br><span class="line">            &#125;</span><br><span class="line">            componentDidUpdate(preProps, preState, snapshotValue) &#123;</span><br><span class="line">                // this.list.scrollHeight 每次比 snapshotValue 多 30px</span><br><span class="line">                this.list.scrollTop += this.list.scrollHeight - snapshotValue</span><br><span class="line">            &#125;</span><br><span class="line">            render() &#123;</span><br><span class="line">                return (</span><br><span class="line">                    &lt;div&gt;</span><br><span class="line">                        &lt;div className=&quot;list&quot; ref=&#123;c =&gt; this.list = c&#125;&gt;</span><br><span class="line">                            &#123;</span><br><span class="line">                                this.state.newsArr.map((item, index) =&gt; &#123;</span><br><span class="line">                                    return &lt;div key=&#123;index&#125; className=&#x27;news&#x27;&gt;&#123;item&#125;&lt;/div&gt;</span><br><span class="line">                                &#125;)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                        &lt;button onClick=&#123;this.clear&#125;&gt;清除定时器&lt;/button&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ReactDOM.render(&lt;NewsList /&gt;, document.getElementById(&#x27;app&#x27;))</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="Diffing算法"><a href="#Diffing算法" class="headerlink" title="Diffing算法"></a>Diffing算法</h1><p><strong>验证Diffing算法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Time extends React.Component &#123;</span><br><span class="line">         state = &#123;date : new Date()&#125;</span><br><span class="line">         componentDidMount()&#123;</span><br><span class="line">             setInterval(() =&gt; &#123;</span><br><span class="line">                 this.setState(&#123;</span><br><span class="line">                     date: new Date()</span><br><span class="line">                 &#125;)</span><br><span class="line">             &#125;, 1000);</span><br><span class="line">         &#125;</span><br><span class="line">         render() &#123;</span><br><span class="line">             // span标签不断变化，外层标签不会受影响，内层input标签也没有影响</span><br><span class="line">             return (</span><br><span class="line">                 &lt;div&gt;</span><br><span class="line">                     &lt;h1&gt;Hellow&lt;/h1&gt;</span><br><span class="line">                     &lt;input type=&quot;text&quot; /&gt;</span><br><span class="line">                     &lt;span&gt;</span><br><span class="line">                         现在是：&#123;this.state.date.toTimeString()&#125;</span><br><span class="line">                         &lt;input type=&quot;text&quot; /&gt;</span><br><span class="line">                     &lt;/span&gt;</span><br><span class="line">                 &lt;/div&gt;</span><br><span class="line">             )</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ReactDOM.render(&lt;Time /&gt;, document.getElementById(&#x27;app&#x27;))</span><br></pre></td></tr></table></figure>
<p><strong>key的作用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line"> &lt;script src=&quot;./js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"> &lt;!-- 用于支持React操作DOM --&gt;</span><br><span class="line"> &lt;script src=&quot;./js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"> &lt;!-- 用于jsx转js --&gt;</span><br><span class="line"> &lt;script src=&quot;./js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"> &lt;!-- 用于对属性标签数据限制 --&gt;</span><br><span class="line"> &lt;script src=&quot;./js/prop-types.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"> &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">     //#region </span><br><span class="line">     // Diffinf算法，逐层对比，最小力度是标签</span><br><span class="line">     // 经典面试题：</span><br><span class="line">     // 1. react/vue 中的key有什么作用？（key的内部原理？）</span><br><span class="line">     // 2. 为什么遍历数组时，key最好不用index?</span><br><span class="line">     //#endregion</span><br><span class="line">     class Person extends React.Component &#123;</span><br><span class="line">         state = &#123;</span><br><span class="line">             persons: [</span><br><span class="line">                 &#123; id: 1, name: &#x27;李四&#x27;, age: 18 &#125;,</span><br><span class="line">                 &#123; id: 2, name: &#x27;张三&#x27;, age: 20 &#125;</span><br><span class="line">             ]</span><br><span class="line">         &#125;</span><br><span class="line">         addData = () =&gt; &#123;</span><br><span class="line">             // this.state.persons.push(&#123;</span><br><span class="line">             //     id: 3, name: &#x27;王五&#x27;, age: 19</span><br><span class="line">             // &#125;)</span><br><span class="line">             this.setState(&#123;persons:[&#123;id: 3, name: &#x27;王五&#x27;, age: 19&#125;,...this.state.persons]&#125;)</span><br><span class="line">         &#125;</span><br><span class="line">         render() &#123;</span><br><span class="line">             return (</span><br><span class="line">                 &lt;div&gt;</span><br><span class="line">                     &lt;h1&gt;展示人员信息&lt;/h1&gt;</span><br><span class="line">                     &lt;button onClick=&#123;this.addData&#125;&gt;添加数据&lt;/button&gt;</span><br><span class="line">                     &lt;ul&gt;</span><br><span class="line">                     &#123;</span><br><span class="line">                         this.state.persons.map((item,index) =&gt; &#123;</span><br><span class="line">                             return &lt;li key=&#123;index&#125;&gt;姓名：&#123;item.name&#125;,年龄：&#123;item.age&#125;&lt;input type=&quot;text&quot; /&gt;&lt;/li&gt;</span><br><span class="line">                         &#125;)</span><br><span class="line">                     &#125;</span><br><span class="line">                     &lt;/ul&gt;</span><br><span class="line">                     &lt;hr/&gt;</span><br><span class="line">                     &lt;ul&gt;</span><br><span class="line">                     &#123;</span><br><span class="line">                         this.state.persons.map((item,index) =&gt; &#123;</span><br><span class="line">                             return &lt;li key=&#123;item.id&#125;&gt;姓名：&#123;item.name&#125;,年龄：&#123;item.age&#125;&lt;input type=&quot;text&quot; /&gt;&lt;/li&gt;</span><br><span class="line">                         &#125;)</span><br><span class="line">                     &#125;</span><br><span class="line">                     &lt;/ul&gt;</span><br><span class="line">                 &lt;/div&gt;</span><br><span class="line">             )</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ReactDOM.render(&lt;Person /&gt;, document.getElementById(&#x27;app&#x27;))</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React知识点————React 路由【第五章】</title>
    <url>/2021/12/30/04.React/</url>
    <content><![CDATA[<h1 id="相关理解"><a href="#相关理解" class="headerlink" title="相关理解"></a>相关理解</h1><ul>
<li>SPA：单页面应用<ul>
<li>整个应用只有一个完整的页面</li>
<li>点击页面链接不会刷新页面，只会页面局部更新</li>
<li>数据通过ajax请求获取，在前端异步展现</li>
</ul>
</li>
<li>路由【一个路由就是一个映射关系（key:value）key:路径 value：function或者component】<ul>
<li>后端路由【value是function，处理客户端提交的请求】<ol>
<li>注册路由：router.get(path,function(req,res))</li>
<li>工作流程：当node接收到请求，根据请求路径找到匹配的路由，调用路由中的函数处理请求，返回请求数据</li>
</ol>
</li>
<li>前端路由【浏览器路由，values是component，用于展示页面内容】<ol>
<li>注册路由 <code>&lt;Route path=&quot;/test&quot; component=&#123;Test&#125;&gt;</code></li>
<li>工作过程：当浏览器的path变成/test,前端路由组件就会变成Test组件 </li>
</ol>
</li>
</ul>
</li>
<li>react-router<ol>
<li>react 的一个插件库</li>
<li>专门实现SPA应用</li>
<li>基于react 项目基本都会用到此库</li>
</ol>
</li>
</ul>
<h1 id="react-router相关API"><a href="#react-router相关API" class="headerlink" title="react-router相关API"></a>react-router相关API</h1><ul>
<li>内置组件<ol>
<li><code>&lt;BrowserRouter&gt;</code></li>
<li><code>&lt;HashRouter&gt;</code></li>
<li><code>&lt;Route&gt;</code></li>
<li><code>&lt;Redirect&gt; ——————react-router-dom@6取消了重定向方法</code></li>
<li><code>&lt;link&gt;</code></li>
<li><code>&lt;NavLink&gt;</code></li>
<li><code>&lt;Switch&gt; ——————&lt;Switch&gt;重命名为&lt;Routes&gt;</code></li>
</ol>
</li>
<li>其他<ol>
<li>history对象</li>
<li>match对象</li>
<li>withRouter对象</li>
</ol>
</li>
<li>注意事项<ul>
<li>Route 组件必须包裹 Routes 组件</li>
<li>Route 组件属性由原来的 component 改为了 element</li>
<li>a标签由 Link组件代替 to跳转路径<ul>
<li><code>&lt;Link className=&quot;list-group-item&quot; to=&quot;/about&quot;&gt;About&lt;/Link&gt;</code></li>
</ul>
</li>
<li>渲染的时候 App组件 包裹 BrowserRouter 或者 HashRouter<ul>
<li><code>ReactDOM.render(&lt;BrowserRouter&gt;&lt;App/&gt;&lt;/BrowserRouter&gt; ,document.getElementById(&#39;root&#39;));</code></li>
</ul>
</li>
<li>Navlink组件 改样式【v6版 支持小写 activeclassname=’active’】【v5 activeClassName】<ul>
<li><code>&lt;NavLink className=&#123;(&#123; isActive &#125;) =&gt; &quot;list-group-item&quot; + (isActive ? &quot; active1&quot; : &quot;&quot;)&#125;  to=&quot;/about&quot;&gt;About&lt;/NavLink&gt;</code></li>
</ul>
</li>
<li>标签体内容是一个特殊的标签属性【this.props.children获取】 【对NavLink 封装到 MyNavLink组件】<ul>
<li><code>&lt;MyNavLink name=&#39;About&#39; to=&quot;/about&quot; a=&#123;1&#125; a=&#123;100&#125; a=&#39;12&#39;&gt;About&lt;/MyNavLink&gt;</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// v6</span><br><span class="line">&lt;Routes&gt;</span><br><span class="line">  &lt;Route path=&quot;/about&quot; element=&#123;&lt;About&gt;&lt;/About&gt;&#125;&gt;&lt;/Route&gt;</span><br><span class="line">  &lt;Route path=&quot;/home&quot; element=&#123;&lt;Home&gt;&lt;/Home&gt;&#125;&gt;&lt;/Route&gt;</span><br><span class="line">&lt;/Routes&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>路由组件和一般组件<ol>
<li>存放位置：一般组件【components】路由组件【pages】</li>
<li>写法：一般组件<code>&lt;demo/&gt;</code> 路由组件 <code>&lt;Route path=&quot;/home&quot; element=&#123;&lt;Home&gt;&lt;/Home&gt;&#125;&gt;&lt;/Route&gt;</code></li>
<li>接收到的props不同【v5版】：  一般组件【写什么接收什么】 路由组件【v5:接收三个固定属性：history、localtion、match】</li>
</ol>
</li>
</ul>
<ul>
<li>Switch组件<ol>
<li>通常情况下，path和component是一一对应的关系。</li>
<li>Switch可以提高路由匹配效率(单一匹配)。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// v5</span><br><span class="line">&lt;Switch&gt;</span><br><span class="line">    &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;&gt;&lt;/Route&gt;</span><br><span class="line">    &lt;Route path=&quot;/about&quot; component=&#123;About&#125;&gt;&lt;/Route&gt;</span><br><span class="line">    &lt;Route path=&quot;/about&quot; component=&#123;Test&#125;&gt;&lt;/Route&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>v5 : 精准匹配 与 模糊匹配 【 开启精准匹配： exact={true}】<ul>
<li><code>&lt;Route exact=&#123;true&#125; path=&quot;/about&quot; element=&#123;&lt;About&gt;&lt;/About&gt;&#125;&gt;&lt;/Route&gt;</code></li>
</ul>
</li>
<li>v5 : Redirect 重定向 v6 :Navigate useNavigate<blockquote>
<ul>
<li><code>//v5 &lt;Redirect to=&quot;/about&quot;&gt;&lt;/Redirect&gt;</code></li>
<li><code>//v6 &lt;Route path=&quot;*&quot; element=&#123;&lt;Navigate to=&quot;/about&quot;/&gt;&#125; /&gt;</code></li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="嵌套路由【v6】"><a href="#嵌套路由【v6】" class="headerlink" title="嵌套路由【v6】"></a>嵌套路由【v6】</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// App.jsx</span><br><span class="line">Routes&gt;</span><br><span class="line">  &lt;Route path=&quot;/about&quot; element=&#123;&lt;About&gt;&lt;/About&gt;&#125;&gt;&lt;/Route&gt;</span><br><span class="line">  &lt;Route path=&quot;/home&quot; element=&#123;&lt;Home&gt;&lt;/Home&gt;&#125;&gt;</span><br><span class="line">    &lt;Route path=&quot;/home/news&quot; element=&#123;&lt;News&gt;&lt;/News&gt;&#125;&gt;&lt;/Route&gt;</span><br><span class="line">    &lt;Route path=&quot;/home/messages&quot; element=&#123;&lt;Messages&gt;&lt;/Messages&gt;&#125;&gt;&lt;/Route&gt;</span><br><span class="line">    &lt;Route path=&quot;/home&quot; element=&#123;&lt;Navigate to=&quot;/home/news&quot; /&gt;&#125; /&gt;</span><br><span class="line">  &lt;/Route&gt;</span><br><span class="line">  &lt;Route path=&quot;*&quot; element=&#123;&lt;Navigate to=&quot;/about&quot; /&gt;&#125; /&gt;</span><br><span class="line">&lt;/Routes&gt;</span><br><span class="line">// Home.jsx</span><br><span class="line">&lt;Outlet&gt;&lt;/Outlet&gt;</span><br></pre></td></tr></table></figure>

<h1 id="路由传值的三种方式-v5-和-v6"><a href="#路由传值的三种方式-v5-和-v6" class="headerlink" title="路由传值的三种方式(v5 和 v6)"></a>路由传值的三种方式(v5 和 v6)</h1><p><strong>1.params参数【传参带/，路由带冒号,useParams】</strong></p>
<blockquote>
<p>v5:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//路由链接(携带参数)：</span><br><span class="line">&lt;Link to=&#x27;/demo/test/tom/18&#x27;&#125;&gt;详情&lt;/Link&gt; </span><br><span class="line">//或 &lt;Link to=&#123;&#123; pathname:&#x27;/demo/test/tom/18&#x27; &#125;&#125;&gt;详情&lt;/Link&gt;</span><br><span class="line"></span><br><span class="line">//注册路由(声明接收)：</span><br><span class="line">&lt;Route path=&quot;/demo/test/:name/:age&quot; component=&#123;Test&#125;/&gt;</span><br><span class="line">    </span><br><span class="line">//接收参数：</span><br><span class="line">this.props.match.params</span><br></pre></td></tr></table></figure>
<blockquote>
<p>v6: useParams 只能在函数组件中使用<br><code>&lt;Link to=&#123;</code>/home/messages/detail/${id}/${title}<code>&#125;&gt;Child1&lt;/Link&gt;</code><br><code>&lt;Route path=&quot;/home/messages/detail:id/:title&quot; component=&#123;Test&#125;/&gt;</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//路由链接(携带参数)：</span><br><span class="line">&lt;Link to=&#123;&#123; pathname:`/b/child1/$&#123;id&#125;/$&#123;title&#125;` &#125;&#125;&gt;Child1&lt;/Link&gt;</span><br><span class="line">//或 &lt;Link  to=&#123;`/b/child1/$&#123;id&#125;/$&#123;title&#125;`&#125;&gt;Child1&lt;/Link&gt; </span><br><span class="line"></span><br><span class="line">//注册路由(声明接收)：</span><br><span class="line">&lt;Route path=&quot;/b/child1/:id/:title&quot; component=&#123;Test&#125;/&gt;</span><br><span class="line">    </span><br><span class="line">//接收参数：</span><br><span class="line">import &#123; useParams &#125; from &quot;react-router-dom&quot;;</span><br><span class="line">const params = useParams();</span><br><span class="line">//params参数 =&gt; &#123;id: &quot;01&quot;, title: &quot;消息1&quot;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#x27;react&#x27;</span><br><span class="line">import &#123; useParams &#125; from &#x27;react-router-dom&#x27;</span><br><span class="line">export default function Detail() &#123;</span><br><span class="line">    const &#123;id,title&#125; = useParams();</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;ID: &#123;id&#125;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;TITLE:&#123;title&#125;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;CONTENT:???&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.search参数【传参带问号，路由不变,useSearchParams】</strong></p>
<blockquote>
<p>v5</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//路由链接(携带参数)：</span><br><span class="line">&lt;Link to=&#x27;/demo/test?name=tom&amp;age=18&#x27;&#125;&gt;详情&lt;/Link&gt;</span><br><span class="line"></span><br><span class="line">//注册路由(无需声明，正常注册即可)：</span><br><span class="line">&lt;Route path=&quot;/demo/test&quot; component=&#123;Test&#125;/&gt;</span><br><span class="line">        </span><br><span class="line">//接收参数：</span><br><span class="line">this.props.location.search</span><br><span class="line"></span><br><span class="line">//备注：获取到的search是urlencoded编码字符串(例如: ?id=10&amp;name=zhangsan)，需要借助query-string解析参数成对象</span><br></pre></td></tr></table></figure>
<blockquote>
<p>v6: useSearchParams 只能在函数组件中使用<br><code>&lt;Link to=&#123;</code>/home/messages/detail?id=${item.id}&amp;title=${item.title}<code>&#125;&gt;&#123;item.title&#125;&lt;/Link&gt;</code><br><code>&lt;Route path=&quot;/home/messages/detail&quot; element=&#123;&lt;Detail&gt;&lt;/Detail&gt;&#125;&gt;&lt;/Route&gt;</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//路由链接(携带参数)：</span><br><span class="line"> &lt;Link className=&quot;nav&quot; to=&#123;`/b/child2?age=20&amp;name=zhangsan`&#125;&gt;Child2&lt;/Link&gt;</span><br><span class="line"></span><br><span class="line">//注册路由(无需声明，正常注册即可)：</span><br><span class="line">&lt;Route path=&quot;/b/child2&quot; component=&#123;Test&#125;/&gt;</span><br><span class="line">        </span><br><span class="line">//接收参数方法1：</span><br><span class="line">import &#123; useLocation &#125; from &quot;react-router-dom&quot;;</span><br><span class="line">import qs from &quot;query-string&quot;;</span><br><span class="line">const &#123; search &#125; = useLocation();</span><br><span class="line">//search参数 =&gt; &#123;age: &quot;20&quot;, name: &quot;zhangsan&quot;&#125;</span><br><span class="line"></span><br><span class="line">//接收参数方法2：</span><br><span class="line">import &#123; useSearchParams &#125; from &quot;react-router-dom&quot;;</span><br><span class="line">const [searchParams, setSearchParams] = useSearchParams();</span><br><span class="line">// console.log( searchParams.get(&quot;id&quot;)); // 12</span><br><span class="line"></span><br><span class="line">//备注：获取到的search是urlencoded编码字符串(例如: ?age=20&amp;name=zhangsan)，需要借助query-string解析参数成对象</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#x27;react&#x27;</span><br><span class="line">// 方式一</span><br><span class="line">import &#123; useSearchParams &#125; from &quot;react-router-dom&quot;;</span><br><span class="line">// 方式二</span><br><span class="line">// import &#123; useLocation &#125; from &quot;react-router-dom&quot;;</span><br><span class="line">// import qs from &quot;query-string&quot;;</span><br><span class="line"></span><br><span class="line">export default function Detail() &#123;</span><br><span class="line">    // 1.接收参数</span><br><span class="line">    const [searchParams, setSearchParams] = useSearchParams();</span><br><span class="line">    // console.log(searchParams.get(&quot;id&quot;));</span><br><span class="line">    // console.log(searchParams.get(&quot;title&quot;));</span><br><span class="line">    // 2.接收参数</span><br><span class="line">    // const &#123; search &#125; = useLocation();</span><br><span class="line">    // let &#123; id, title &#125; = qs.parse(search)</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;ID: &#123;searchParams.get(&quot;id&quot;)&#125;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;TITLE: &#123;searchParams.get(&quot;title&quot;)&#125;&lt;/li&gt;</span><br><span class="line">                &#123;/* &lt;li&gt;ID: &#123;id&#125;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;TITLE: &#123;title&#125;&lt;/li&gt; */&#125;</span><br><span class="line">                &lt;li&gt;CONTENT:???&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.state参数【传参带state属性，路由不变,useLocation，[浏览器路径：/home/messages/detail，没有带参数]】</strong></p>
<blockquote>
<p>v5</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//路由链接(携带参数)：</span><br><span class="line">&lt;Link to=&#123;&#123;pathname:&#x27;/demo/test&#x27;,state:&#123;name:&#x27;tom&#x27;,age:18&#125;&#125;&#125;&gt;详情&lt;/Link&gt;</span><br><span class="line"></span><br><span class="line">//注册路由(无需声明，正常注册即可)：</span><br><span class="line"> &lt;Route path=&quot;/demo/test&quot; component=&#123;Test&#125;/&gt;</span><br><span class="line">    </span><br><span class="line">//接收参数：</span><br><span class="line">this.props.location.state</span><br><span class="line"></span><br><span class="line">//备注：刷新也可以保留住参数</span><br></pre></td></tr></table></figure>
<blockquote>
<p>v6<br><code>&lt;Link to=&#123;</code>/home/messages/detail<code>&#125; state=&#123;&#123; id: item.id, title: item.title &#125;&#125; &gt;&#123;item.title&#125;&lt;/Link&gt;</code><br><code>&lt;Route path=&quot;/home/messages/detail&quot; element=&#123;&lt;Detail&gt;&lt;/Detail&gt;&#125;&gt;&lt;/Route&gt;</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//通过Link的state属性传递参数</span><br><span class="line"> &lt;Link</span><br><span class="line">     className=&quot;nav&quot;</span><br><span class="line">     to=&#123;`/b/child2`&#125;</span><br><span class="line">     state=&#123;&#123; id: 999, name: &quot;i love merlin&quot; &#125;&#125; </span><br><span class="line"> &gt;</span><br><span class="line">    Child2</span><br><span class="line">&lt;/Link&gt;</span><br><span class="line"></span><br><span class="line">//注册路由(无需声明，正常注册即可)：</span><br><span class="line">&lt;Route path=&quot;/b/child2&quot; component=&#123;Test&#125;/&gt;</span><br><span class="line">    </span><br><span class="line">//接收参数：</span><br><span class="line">import &#123; useLocation &#125; from &quot;react-router-dom&quot;;</span><br><span class="line">const &#123; state &#125; = useLocation();</span><br><span class="line">//state参数 =&gt; &#123;id: 999, name: &quot;我是梅琳&quot;&#125;</span><br><span class="line"></span><br><span class="line">//备注：刷新也可以保留住参数</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#x27;react&#x27;</span><br><span class="line">import &#123; useLocation &#125; from &quot;react-router-dom&quot;;</span><br><span class="line">&#123;/* &lt;Route path=&quot;/home/messages/detail&quot; element=&#123;&lt;Detail&gt;&lt;/Detail&gt;&#125;&gt;&lt;/Route&gt; */&#125;</span><br><span class="line">&#123;/* &lt;Link to=&#123;`/home/messages/detail`&#125; state=&#123;&#123; id: item.id, title: item.title &#125;&#125; &gt;&#123;item.title&#125;&lt;/Link&gt; */&#125;</span><br><span class="line"></span><br><span class="line">export default function Detail()&#123;</span><br><span class="line">    const &#123; state &#125; = useLocation();</span><br><span class="line">    console.log(useLocation());</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;ID: &#123;state.id&#125;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;TITLE: &#123;state.title&#125;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;CONTENT:???&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="class组件接收参数"><a href="#class组件接收参数" class="headerlink" title="class组件接收参数"></a>class组件接收参数</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component, useImperativeHandle &#125; from &#x27;react&#x27;</span><br><span class="line">import &#123; useParams &#125; from &quot;react-router-dom&quot;;</span><br><span class="line">// APP.jsx 路由配置</span><br><span class="line">&#123;/* &lt;Route path=&quot;/home/messages/detail/:id/:title&quot; element=&#123;&lt;Detail&gt;&lt;/Detail&gt;&#125;&gt;&lt;/Route&gt; */&#125;</span><br><span class="line">// Messages.jsx 列表页面</span><br><span class="line">&#123;/* &lt;Link to=&#123;`/home/messages/detail/$&#123;item.id&#125;/$&#123;item.title&#125;`&#125;&gt;&#123;item.title&#125;&lt;/Link&gt; */&#125;</span><br><span class="line"></span><br><span class="line">function A(props) &#123;</span><br><span class="line">    // 获取动态路由的值</span><br><span class="line">    const params = useParams();</span><br><span class="line">    useImperativeHandle(props.onRef, () =&gt; &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            params,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return (</span><br><span class="line">        &lt;span&gt;&lt;/span&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default class Detail extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            // 创建ref</span><br><span class="line">            funRef: React.createRef(),</span><br><span class="line">            data:&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    paramsData =  ()=&gt; &#123;</span><br><span class="line">        let &#123;funRef&#125; = this.state;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            data:funRef.current.params</span><br><span class="line">        &#125;)</span><br><span class="line">        console.log(funRef.current.params);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        let &#123;funRef,data&#125; = this.state;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li&gt;ID: &#123;data.id&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;TITLE: &#123;data.title&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;CONTENT:???&lt;/li&gt;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">                &lt;button onClick=&#123;this.paramsData&#125;&gt;获取params数据&lt;/button&gt;</span><br><span class="line">                &lt;A onRef=&#123;funRef&#125; style=&#123;&#123; display: &#x27;none&#x27; &#125;&#125;&gt;&lt;/A&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="push-和-replace-模式"><a href="#push-和-replace-模式" class="headerlink" title="push 和 replace 模式"></a>push 和 replace 模式</h1><p><strong>react 默认是push模式</strong></p>
<ul>
<li>replace跳转不会形成history，不可返回到上一层<br><code>this.props.history.replace(‘router地址’)</code></li>
<li>push跳转会形成history，可返回到上一层<br><code>this.props.history.push(‘router地址’)</code></li>
</ul>
<h1 id="编程式跳转"><a href="#编程式跳转" class="headerlink" title="编程式跳转"></a>编程式跳转</h1><p><strong>函数式组件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// v5</span><br><span class="line">import &#123; useHistory &#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line"></span><br><span class="line">function MyButton() &#123;</span><br><span class="line">  let history = useHistory();</span><br><span class="line">  function handleClick() &#123;</span><br><span class="line">    history.push(&#x27;/home&#x27;);</span><br><span class="line">  &#125;;</span><br><span class="line">  return &lt;button onClick=&#123;handleClick&#125;&gt;Submit&lt;/button&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// v6</span><br><span class="line">import &#123; useNavigate &#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line"></span><br><span class="line">function MyButton() &#123;</span><br><span class="line">  let navigate = useNavigate();</span><br><span class="line">  function handleClick() &#123;</span><br><span class="line">    navigate(&#x27;/home&#x27;);</span><br><span class="line">  &#125;;</span><br><span class="line">  return &lt;button onClick=&#123;handleClick&#125;&gt;Submit&lt;/button&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// v5</span><br><span class="line">history.push(&#x27;/home&#x27;);</span><br><span class="line">history.replace(&#x27;/home&#x27;);</span><br><span class="line"></span><br><span class="line">// v6</span><br><span class="line">navigate(&#x27;/home&#x27;);</span><br><span class="line">navigate(&#x27;/home&#x27;, &#123;replace: true&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 	import &#123; useNavigate &#125; from &#x27;react-router-dom&#x27;</span><br><span class="line"></span><br><span class="line">2. 	let navigate = useNavigate();</span><br><span class="line">	function showReplace(id, title) &#123;</span><br><span class="line">	    // params参数</span><br><span class="line">	    // navigate(`/home/messages/detail/$&#123;id&#125;/$&#123;title&#125;`,&#123;replace: true&#125;);</span><br><span class="line">	    // search参数</span><br><span class="line">	    navigate(`/home/messages/detail/?id=$&#123;id&#125;&amp;title=$&#123;title&#125;`,&#123;replace: true&#125;)</span><br><span class="line">	    // navigate state参数 【似乎没有这种方式】</span><br><span class="line">	    // navigate(`/home/messages/detail`, &#123; &#x27;id&#x27;:id, &#x27;title&#x27;:title &#125;)</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">3.  &lt;button onClick=&#123;() =&gt; showReplace(item.id, item.title)&#125;&gt;replace查看&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p><strong>类组件 v5</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.props.history.replace(‘router地址’)</span><br><span class="line">this.props.history.push(‘router地址’)</span><br></pre></td></tr></table></figure>

<h1 id="withRouter-【v5有，v6应该是删除了，不能使用】"><a href="#withRouter-【v5有，v6应该是删除了，不能使用】" class="headerlink" title="withRouter 【v5有，v6应该是删除了，不能使用】"></a>withRouter 【v5有，v6应该是删除了，不能使用】</h1><p><strong>withRouter:加工一般组件，让一般组件具备路由组件的API,返回值是一个新组件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#x27;react&#x27;</span><br><span class="line">import &#123; withRouter &#125; from &#x27;react-router-dom&#x27;</span><br><span class="line"></span><br><span class="line"> class Header extends Component &#123;</span><br><span class="line">    back = () =&gt; &#123;</span><br><span class="line">        // this.props.history.goBack()</span><br><span class="line">    &#125;</span><br><span class="line">    // forward = () =&gt; &#123;</span><br><span class="line">    //     this.props.history.goForward()</span><br><span class="line">    // &#125;</span><br><span class="line">    // go = () =&gt; &#123;</span><br><span class="line">    //     this.props.history.go(-2)</span><br><span class="line">    // &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;h2&gt;React Router Demo111&lt;/h2&gt;</span><br><span class="line">                    &lt;button onClick=&#123;this.back&#125;&gt;回退&lt;/button&gt;</span><br><span class="line">                    &lt;button onClick=&#123;this.forward&#125;&gt;前进&lt;/button&gt;</span><br><span class="line">                    &lt;button onClick=&#123;this.go&#125;&gt;go&lt;/button&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default withRouter(Header)</span><br></pre></td></tr></table></figure>

<h1 id="BrowserRouter-和-HashRouter-的区别"><a href="#BrowserRouter-和-HashRouter-的区别" class="headerlink" title="BrowserRouter 和 HashRouter 的区别"></a>BrowserRouter 和 HashRouter 的区别</h1><p>1.底层原理不一样：<br>            BrowserRouter使用的是H5的history API，不兼容IE9及以下版本。<br>            HashRouter使用的是URL的哈希值。<br>2.path表现形式不一样<br>            BrowserRouter的路径中没有#,例如：localhost:3000/demo/test<br>            HashRouter的路径包含#,例如：localhost:3000/#/demo/test<br>3.刷新后对路由state参数的影响【v6没有影响】<br>            (1).BrowserRouter没有任何影响，因为state保存在history对象中。<br>            (2).HashRouter刷新后会导致路由state参数的丢失！！！<br>4.备注：HashRouter可以用于解决一些路径错误相关的问题。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
</search>
